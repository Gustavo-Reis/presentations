<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<title>Introduction to C++</title>

		<meta name="description" content="Introduction to C++">
		<meta name="author" content="Gustavo Reis">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/serif.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/obsidian.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style type="text/css">
			.output{
				font-size:larger;
				background-color:black;
				color:lightgrey;
			}
		</style>

	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Introduction to C++</h1>
					<h2>"A tour of C++" - Bjarne Stroustrup</h2>
					<h2>(Chapters 1, 2 and 3)</h2>
				</section>
				<section>
					<section>
						<h1>Before C++, there was C</h1>
						<p class="fragment">The C language was developed in 1972 by Dennis Ritchie at Bell labs</p>
						<p class="fragment">C was invented for writing operating systems</p>
						<p class="fragment">Primary goals:</p>
						<ul>
							<li class="fragment">produce a minimalistic language that was easy to compile</li>
							<li class="fragment">allow efficient access to memory</li>
							<li class="fragment">produce efficient code</li>
							<li class="fragment">do not need extensive run-time support.</li>
						</ul>
						<p class="fragment">For an high-level language, it was designed to be fairly low-level.</p>
						<p class="fragment">Platform-independent programming</p>
					</section>
					<section>
						<p class="fragment">C ended up being so efficient and flexible that in 1973, Ritchie and Ken Thompson rewrote most of the UNIX operating system using C<p>
						<p class="fragment">Many previous operating systems had been written in assembly<p>
						<p class="fragment">Unlike assembly, which ties a program to a specific CPU, C’s excellent portability allowed UNIX to be recompiled on many different types of computers speeding its adoption<p>
						<p class="fragment">Thanks to the portability of UNIX, C becomes very popular<p>
						<p class="fragment">In 1978, Brian Kerrigan and Dennis Ritchie published a book entitled "The C Programming Language"<p>
						<p class="fragment">This book caused a revolution in the computing world<p>
						<p class="fragment">In 1983, the American National Standards Institute (ANSI) established a committee to provide a modern, comprehensive definition of C.<p>
						<p class="fragment">The resulting definition, the ANSI standard, or "ANSI C", was completed in 1989<p>
						<p class="fragment">In 1990 the International Standardization Organization (ISO) adopted ANSI C (with a few minor modifications)<p>
						<p class="fragment">This version of C became known as C90<p>
						<p class="fragment">Compilers eventually became ANSI C/C90 compliant, and programs desiring maximum portability were coded to this standard<p>
					</section>
				</section>
				<section>
					<section>
						<h1>History of C++</h1>
						<p class="fragment">Was developed by Bjarne Stroustrup at Bell Labs as an extension to C, starting at 1979</p>
						<p class="fragment">New features: classes, member functions, derived classes, separate compilation, public and private access control, friends, type checking of function arguments, default arguments, inline functions, overloaded assignment operator, constructors, destructors…</p>
						<p class="fragment">Formerly known as "C with Classes"</p>
						<p class="fragment">In 1983, the name of the language changes from "C with classes" to "C++"</p>
						<p class="fragment">The ++operator in the C language is an operator for incrementing a variable</p>
						<p class="fragment">The purpose of C++ is to make writing good programs easier and more pleasant for the individual programmer</p>
					</section>
					<section>
						<p class="fragment">The first edition of Stroustrup's book, "The C++ Programming Language", was published in early 1986</p>
						<p class="fragment">After the release of Version 2.0 in 1989, C++ was rapidly acknowledged as a serious, useful language</p>
						<p class="fragment">In 1997, a committee of the American National Standards Institute (ANSI) completed and published internally the Draft Standard - "The C++ Language"</p>
						<p class="fragment">The third edition of Stroustrup's book, was published in 1997 and is widely regarded as the definitive C++ reference.</p>
						<p class="fragment">C++ was ratified in 1998 by the ISO committee, and again in 2003 (called C++03)</p>
						<p class="fragment">Two updates to the C++ language (C++11 and C++14, ratified in 2011 and 2014 accordingly) have been made since then, adding additional functionality to the language</p>
					</section>
				</section>
				<section>
					<h1>About C++</h1>
					<p class="fragment">C++ is object oriented</p>
					<p class="fragment">C++ is statically typed</p>
					<p class="fragment">C++ is one of the predominant languages for the development of all kind of technical and commercial software</p>
					<p class="fragment">C++ has been used to develop other types of programming tools</p>
					<p class="fragment">C++ was built for speed and portability</p>
					<p class="fragment">C++ is a compiler type programming language: the source code is translated (compiled) into an intermediary form (Object file); different object files are combined into an executable program by a Linker</p>
				</section>
				<section>
					<h1>Deployment Cycle</h1>
					<img class="plain" src="cpp/CPPcycle.png" class="clean" width="60%"><br>
					Image from: <a href="http://www.w3processing.com/index.php?subMenuLoad=cpp/intro/Cycle.php">http://www.w3processing.com/index.php?subMenuLoad=cpp/intro/Cycle.php</a>
				</section>
				<section>
					<h1>C++ Compiling</h1>
					<p class="fragment">A C++ program typically consists of many source code files (usually simply called source files)</p>
					<p class="fragment">There are two kind of source code files:</p>
					<ul>
						<li class="fragment"><b>header files</b>, which contains constants, declarations and redefined types and have .hpp extension (prefered) or .h</li>
						<li class="fragment"><b>source files</b>, which contain the implementation code for any declaration done in the header files, and have cpp extension</li>
					</ul>
					<p class="fragment">Each source file is processed by the preprocessor, generating a text file</p>
					<p class="fragment">The text file is processed by the compiler (it is compiled) generating an object code (assembler) file</p>
					<p class="fragment">All the object files are combined by a linker, yielding an executable file</p>
				</section>
				<section>
					<h1>C++ Compiling Cycle</h1>
					<img class="plain" src="cpp/compilingCycle.png" width="20%">
				</section>
				<section>
					<h1>C++ Programs</h1>
					<p class="fragment">An executable program is created for a specific hardware/system combination: it is not portable, say, from a Mac to a Windows PC</p>
					<p class="fragment">When we talk about portability of C++ programs, we usually mean portability of source code: the source code can be successfully compiled and run on a variety of systems</p>
					<p class="fragment">The ISO C++ standard defines two kinds of entities:</p>
					<ul>
						<li class="fragment"><b>Core language features</b>, such as built-in types (e.g., <code>char</code> and <code>int</code>) and loops (e.g., <code>for</code>-statements and <code>while</code>-statements) </li>
						<li class="fragment"><b>Standard-library components</b>, such as containers (e.g., <code>vector</code> and <code>map</code>) and I/O operations (e.g., <code><<</code> and <code>getline()</code>)</li>
					</ul>
				</section>
				<section>
					<section>
						<h1>Hello World</h1>
						<p class="fragment">The minimal C++ program is:</p>
						<pre class="fragment"><code style="font-size:larger;">int main() { } // the minimal C++ program</code></pre>
						<p class="fragment">This defines a function called <code>main</code>, which takes no arguments ad does nothing.</p>
						<p class="fragment">Curly braces, <code>{ }</code>, express grouping in C++;</p>
						<p class="fragment">Double slash, <code>//</code>, begins a comment that extends to the end of the line</p>
						<p class="fragment">The <code>int</code> value returned by <code>main</code>, if any, is the program’s return value to "the system"</p>
						<p class="fragment">If no value is returned, the system will receive a value indicating successful completion</p>
						<p class="fragment">A nonzero value from <code>main()</code> indicates failure</p>
					</section>
					<section>
						<p class="fragment">Typically, a program produces some output</p>
						<p class="fragment">Here is a program that writes <code>Hello, World!</code>:</p>
						<pre class="fragment"><code style="font-size:larger;">#include &lt;iostream&gt;

int main()
{
    std::cout << "Hello, World!\n";
}</code></pre>
						<p class="fragment">The line <code>#include &lt;iostream&gt;</code> instructs the compiler to include the declarations of the standard stream I/O facilities as found in <code>iostream</code></p>
						<p class="fragment">Without these declarations, the expression <code>std::cout << "Hello, World!\n"</code> would make no sense.</p>
						<p class="fragment">The operator <code><<</code> ("put to") writes its second argument onto its first</p>
						<p class="fragment">In this case, the string literal <code>"Hello, World!\n"</code> is written onto the standard output stream <code>std::cout</code></p>
					</section>
					<section>
						<p class="fragment">A string literal is a sequence of characters surrounded by double quotes</p>
						<p class="fragment">In a string literal, the backslash character <code>\</code> followed by another character denotes a single "special character"</p>
						<p class="fragment">In this case, <code>\n</code> is the newline character, so that the characters written are Hello, World! followed by a newline.</p>
						<p class="fragment">This is similar to:</p>
						<pre class="fragment"><code style="font-size:larger;">#include &lt;iostream&gt;

int main()
{
    std::cout << "Hello, World!" << std::endl;
}</code></pre>
					</section>
					<section>
						<p class="fragment">The <code>std::</code> specifies that the name <code>cout</code> is to be found in the standard-library namespace</p>
						<p class="fragment">This is similar to:</p>
						<pre class="fragment"><code style="font-size:larger">#include &lt;iostream&gt;
using namespace std;

int main()
{
    cout << "Hello, World!" << endl;
}</code></pre>
					</section>
					<section>
						<p class="fragment">Essentially, all executable code is placed in functions and called directly or indirectly from <code>main()</code></p>
						<pre class="fragment"><code style="font-size:larger;">#include &lt;iostream&gt;
using namespace std;

double square(double x)
{
    return x * x;
}

void print_square(double x)
{
    cout << "the square of " << x << " is " << square(x) << "\n";
}

int main()
{
    print_square(1.234);         // print the square of 1.234 is 1.52276
}</code></pre>
						<p class="fragment">A "return type" <code>void</code> indicates that a function does not return a value</p>
					</section>
				</section>
				<section>
					<section>
						<h1>Types, Variables and Arithmetic</h1>
						<p class="fragment">Every name and every expression has  a type that determines the operations that may be performed on it</p>
						<p class="fragment">For example, the declaration</p>
						<pre class="fragment"><code style="font-size:larger">int inch;</code></pre>
						<p class="fragment">specifies that <code>inch</code> is of type <code>int</code>; that is, <code>inch</code> is an integer variable.</p>
						<p class="fragment">A declaration is a statement that introduces a name into the program</p>
						<p class="fragment">It specifies a type for the named entity:</p>
						<ul>
							<li class="fragment">A <b>type</b> defines a set of possible values and a set of operations (for an object)</li>
							<li class="fragment">An <b>object</b> is some memory that holds a value of some type</li>
							<li class="fragment">A <b>value</b> is a set of bits interpreted according to a type</li>
							<li class="fragment">A <b>variable</b> is a named object</li>
						</ul>
					</section>
					<section>
						<p class="fragment">C++ offers a variety of fundamental types. For example:</p>
						<pre class="fragment"><code style="font-size:larger">bool		// Boolean, possible values are true or false
char		// character, for example, 'a', 'z' and '9'
int 		// integer, for example, -273, 42 and 1066
double		// double-precision floating-point number, for example, -273.15, 3.14, and 299793.0
unsigned	// non-negative integer, for example, 0, 1, and 999</code></pre>
						<p class="fragment">Each fundamental type corresponds directly to hardware facilities and has a fixed size that determines the range of values that can be stored in it:</p>
						<p class="fragment"><code>bool:&nbsp;&nbsp;</code><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
						<p class="fragment"><code>char:&nbsp;&nbsp;</code><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
						<p class="fragment"><code>int:&nbsp;&nbsp;&nbsp;</code><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
						<p class="fragment"><code>double:</code><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="border:1px solid black">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p>
					</section>
					<section>
						<p class="fragment">A <code>char</code> variable is of the natural size to hold a character on a given machine (typically an 8-bit byte)</p>
						<p class="fragment">Sizes of other types are quoted in multiples of the size of a <code>char</code></p>
						<p class="fragment">The size of a type is implementation-defined (i.e., it can vary among different machines) and can be obtained by the <code>sizeof</code> operator</p>
						<p class="fragment">For example, <code>sizeof(char)</code> equals to <code>1</code> and <code>sizeof(int)</code> is often <code>4</code></p>
					</section>
					<section>
						<table style="font-size:35px">
							<tr>
								<th>Name</th>
								<th>Description</th>
								<th>Size</th>
								<th>Range</th>
							</tr>
							<tr style="background-color:#EEEEEE;">
								<td><code>char</code></td>
								<td>Character or small integer</td>
								<td>1 byte</td>
								<td>signed: -128 to 127<br>unsigned: 0 to 255</td>
							</tr>
							<tr>
								<td><code>short int<br>(short)</code></td>
								<td>Short integer</td>
								<td>2 bytes</td>
								<td>signed: -32768 to 32767<br>unsigned: 0 to 65535</td>
							</tr>
							<tr style="background-color:#EEEEEE;">
								<td><code>int</code></td>
								<td>Integer</td>
								<td>4 bytes</td>
								<td>signed: -2147483648 to 2147483647<br>unsigned: 0 to 4294967295</td>
							</tr>
							<tr>
								<td><code>long int<br>(long)</code></td>
								<td>Long integer</td>
								<td>4 bytes</td>
								<td>signed: -2147483648 to 2147483647<br>unsigned: 0 to 4294967295</td>
							</tr>
							<tr style="background-color:#EEEEEE;">
								<td><code>bool</code></td>
								<td>Boolean value. It can take one of two values: true or false</td>
								<td>1 byte</td>
								<td>true or false<br>&nbsp;</td>
							</tr>
							<tr>
								<td><code>float</code></td>
								<td>Floating point number</td>
								<td>4 bytes</td>
								<td>3.4e +/- 38 (7 digits)<br>&nbsp;</td>
							</tr>
							<tr style="background-color:#EEEEEE;">
								<td><code>double</code></td>
								<td>Double precision floating point number</td>
								<td>8 bytes</td>
								<td>1.7e +/- 308 (15 digits)<br>&nbsp;</td>
							</tr>
							<tr>
								<td><code>long double</code></td>
								<td>Long double precision floating point number</td>
								<td>8 bytes</td>
								<td>1.7e +/- 308 (15 digits)<br>&nbsp;</td>
							</tr>
							<tr style="background-color:#EEEEEE;">
								<td><code>wchar_t</code></td>
								<td>Wide character</td>
								<td>2 bytes</td>
								<td>1 wide character<br>&nbsp;</td>
							</tr>
						</table>
					</section>
					<section>
						<pre><code style="font-size:larger">#include &lt;iostream&gt;

int main() {
  using std::cout;
  cout << "The size of a bool is:\t\t" << sizeof(bool)   << " bytes.\n";
  cout << "The size of a char is:\t\t" << sizeof(char)   << " bytes.\n";
  cout << "The size of a short int is:\t" << sizeof(short)  << " bytes.\n";
  cout << "The size of an int is:\t\t" << sizeof(int)    << " bytes.\n";
  cout << "The size of a long int is:\t" << sizeof(long)   << " bytes.\n";
  cout << "The size of a float is:\t\t" << sizeof(float)  << " bytes.\n";
  cout << "The size of a double is:\t" << sizeof(double) << " bytes.\n";
  return 0;
}</code></pre>
					</section>
					<section>
						<p>The arithmetic operators can be used for appropriate combinations of these types:</p>
						<pre><code style="font-size:larger">x+y     // plus
+x      // unary plus
x−y     // minus
-x      // unary minus
x∗y     // multiply
x/y     // divide
x%y     // remainder (modulus) for integers</code></pre>
					</section>
					<section>
						<p>So can the comparison operators:</p>
						<pre><code style="font-size:larger">x==y    // equal
x!=y    // not equal
x&lt;y     // less than
x&gt;y     // greater than
x<=y    // less than or equal
x>=y    // greater than or equal</code></pre>
					</section>
					<section>
						<p>Logical operators are also provided:</p>
						<pre><code style="font-size:larger">x&y     // bitwise and
x|y     // bitwise or
x^y     // bitwise exclusive or
~x      // bitwise complement
x&&y    // logical and
x||y    // logical or</code></pre>
					</section>
					<section>
						<p>In assignments and in arithmetic operations, C++ performs all meaningful conversions between the basic types so that they can be mixed freely:</p>
						<pre><code style="font-size:larger">void some_function()  //function that doesn't return a value
{
    double d = 2.2;   // initialise floating point number
    int i = 7;        // initialise integer
    d = d + i;        // assign sum to d
    i = d * i;        // assign product to i (truncating the double d*i to an int)
}</code></pre>
					</section>
					<section>
						<p>C++ offers a variety of notations for expressing initialisation, such as the <code>=</code> used on previous slide, and an universal form based on curly-brace-delimited initialiser lists:</p>
						<pre><code style="font-size:larger">double d1 = 2.3;            // initialize d1 to 2.3
double d2 {2.3};            // initialize d2 to 2.3
complex&lt;double&gt; z1 = 1;     // a complex number with double-precision floating-point scalars
complex&lt;double&gt; z2 {d1,d2};
complex&lt;double&gt; z3 = {1,2}; // the = is optional with {...}</code></pre>
					</section>
					<section>
						<p class="fragment">The <code>=</code> form is traditional and dates back to C, but if in doubt, use the general {}-list form.</p>
						<p class="fragment">This saves from conversions that lose information:</p>
						<pre class="fragment"><code style="font-size:larger">int i1 = 7.2;   // i1 becomes 7
int i2 {7.2};   // error: floating-point to integer conversion
int i3 = {7.2}; // error: floating-point to integer conversion (the = is redundant)</code></pre>
					</section>
					<section>
						<p>When defining a variable, you don’t actually need to state its type explicitely when it can be deduced from the initialiser:</p>
						<pre><code style="font-size:larger">auto b = true;     // a bool
auto ch = 'x';     // a char
auto i = 123;      // an int
auto d = 1.2;      // a double
auto z = sqrt(y);  // z has the type of whatever sqrt(y) returns</code></pre>
					</section>
					<section>
						<p class="fragment">With auto, we use the = because there is no potentially troublesome type conversion involved</p>
						<p class="fragment">Use auto where you don’t have a specific reason to mention the type explicitly:</p>
						<ul>
							<li class="fragment">The definition is in a large scope where we want the to make the type clearly visible to readers of our code</li>
							<li class="fragment">We want to be explicit about a variable’s range or precision (e.g.: <code>double</code> rather than <code>float</code>)</li>
						</ul>
						<p class="fragment">Using auto avoids redundancy and typing long type names.</p>
						<p class="fragment">This is especially important in generic programming where the exact type of an object can be hard for the programmer to know and the typenames can be quite long.</p>
					</section>
					<section>
						<p>C++ also offers more specific operators for modifying a variable:</p>
						<pre><code style="font-size:larger">x+=y;  // x = x + y
++x;   // increment: x = x + 1
x-=y;  // x = x - y
--x;   // decrement: x = x - 1
x*=y;  // scaling: x = x * y
x/=y;  // scaling: x = x / y
x%=y;  // x = x % y</code></pre>
					</section>
				</section>
				<section>
					<h1>Scope and Lifetime</h1>
					<p class="fragment">The scope of a name is the area of the code where that name can be used.</p>
					<p class="fragment">The scope of any name is basically the block in which is defined.</p>
					<p class="fragment">A declaration introduces its name into a scope:</p>
					<ul>
						<li class="fragment">Local scope;</li>
						<li class="fragment">Class scope;</li>
						<li class="fragment">Namespace scope.</li>
					</ul>
				</section>
				<section>
					<h1>Local Scope</h1>
					<p class="fragment">A name declared in a function or lambda is called a <b>local name</b>.</p>
					<p class="fragment">Its scope extends from its point of declaration to the end of the block in which its declaration occurs.</p>
					<p class="fragment">A block is delimited by a <code>{}</code> pair.</p>
					<p class="fragment">Function argument names are considered local names.</p>
				</section>
				<section>
					<h1>Class Scope</h1>
					<p class="fragment">A name is called a <b>member name</b> (or a <b>class member name</b>) if it is defined in a class, outside any function, lambda or <code>enum class</code>.</p>
					<p class="fragment">Its scope extends from the opening <code>{</code> of its enclosing declaration to the end of that declaration.</p>
				</section>
				<section>
					<section>
						<h1>Namespace Scope</h1>
						<p class="fragment">A name is called a <b>namespace member name</b> if it is defined in a namespace outside any function, lambda, or <code>enum class</code>.</p>
						<p class="fragment">Its scope extends from the point of declaration to the end of its namespace.</p>
						<p class="fragment">A name not declares inside any other construct is called a <b>global name</b> and is said to be in the <b>global namespace</b>.</p>
					</section>
					<section>
						<p class="fragment">In addition, you can have objects without names, such as temporaries and objects created using <code>new</code>:</p>
						<pre class="fragment"><code  style="font-size:larger">vector&lt;int&gt; vec;  // vec is global (a global vector of integers)
struct Record{
    string name;  // name is a member (a string member)
    // ...
};

void fct(int arg) // fct is global (a global function declaration)
                  // arg is local (an integer argument)
{
    string motto {"Who dares win"}; // motto is local
    auto p = new Record{"Hume"};    // p point to an unnamed Record (created by new)
    //...
}</code></pre>						
					</section>
					<section>
						<p class="fragment">An object must be constructed (initialized) before it is used and will be destroyed at the end of its scope.</p>
						<p class="fragment">For a namespace object, the point of destruction is the end of the program.</p>
						<p class="fragment">For a member, the point of destruction is determined by the point of destruction of the object which it is a member.</p>
						<p class="fragment">An object created by <code>new</code> "lives" until destroyed by <code>delete</code>.</p>
					</section>
				</section>
				<section>
					<section>
						<h1>Static Local Variables</h1>
						<p class="fragment">The <code>static</code> local variables are exactly like global variables, only they have local scope, as shown in the following code:</p>
						<pre class="fragment"><code style="font-size:larger">void testFunc() {
    static int runCount = 0; // this only runs ONCE, even on
    // subsequent calls to testFunc()
    cout << "Ran this function " << ++runCount << " times" << endl;
}  // runCount stops being in scope, but does not die here

int main()
{
    testFunc();
    testFunc();
}</code></pre>
						<pre class="fragment"><div style="font-size:larger; background-color:black; color:white;" >Ran this function 1 times
Ran this function 2 times</div></pre>
					</section>
					<section>
						<p class="fragment">With the use of the <code>static</code> keyword inside <code>testFunc()</code>, the <code>runCount</code> variable remembers its value between calls of <code>testFunc()</code>.</p>
						<p class="fragment">So, the output of the two separate preceding runs of <code>testFunc()</code> is:</p>
						<pre class="fragment"><div class="output" >Ran this function 1 times
Ran this function 2 times</div></pre>
					</section>
				</section>
				<section>
					<section>
						<h1>Constants</h1>
						<p class="fragment">C++ supports two notions of immutability:</p>
						<ul>
							<li class="fragment"><code>const</code>:</li>
							<ul>
								<li class="fragment">Means roughly "I promise not to change this value";</li>
								<li class="fragment">Used primarily to specify interfaces, so that data can be passed to functions with out fear of being modified;</li>
								<li class="fragment">The compiler enforces the promise made by <code>const</code>.</li>
							</ul>
							<li class="fragment"><code>constexpr</code>:</li>
							<ul>
								<li class="fragment">Means roughly "to be evaluated at compile time";</li>
								<li class="fragment">Used primarily to specify constants, to allow placement of data in readonly memory (where it is unlikely to be corrupted) and for performance.</li>
							</ul>
						</ul>
					</section>
					<section>
						<pre><code style="font-size:larger">const int dmv = 17;                      // dmv is a named constant
int var = 17;                            // var is not a constant

constexpr double max1 = 1.4*square(dmv); // OK if square(17) is a constant expression
constexpr double max2 = 1.4*square(var); // error: var is not a constant expression
const double max3 = 1.4*square(var);     // OK, may be evaluated at run time

double sum(const vector&lt;double&gt;&);       // sum will not modify its argument
vector&lt;double&gt; v {1.2, 3.4, 4.5};        // v is not a constant
const double s1 = sum(v);                // OK: evaluated at run time
constexpr double s2 = sum(v);            // error: sum(v) not constant expression</code></pre>
					</section>
					<section>
						<p class="fragment">For a function to be usable in a <b>constant expression</b>, that is, in an expression that will be evaluated by the compiler, it must be <code>defined constexpr</code>:</p>
						<pre class="fragment"><code style="font-size:larger">constexpr double square(double x) { return x*x; }</code></pre>
						<p class="fragment">To be <code>constexpr</code>, a function must be rather simple: just a return-statement computing a value.</p>
						<p class="fragment">A <code>constexpr</code> function can be used for non-constant arguments, but when that is done the result is not a constant expression.</p>
						<p class="fragment">We allow a <code>constexpr</code> function to be called with non-constant-expression arguments in contexts that do not require constant expressions, so that we don’t have to define essentially the same function twice: once for constant expressions and once for variables.</p>
					</section>
				</section>
				<section>
					<h1>Arrays, Pointers and References</h1>
				</section>
				<section>
					<section>
						<h1>Arrays</h1>
						<p class="fragment">An array of elements of type char can be declared like this:</p>
						<pre class="fragment"><code style="font-size:larger">char v[6]; // array of 6 characters</code></pre>
						<p class="fragment">In declarations, <code>[]</code> means “array of”.</p>
						<p class="fragment">All arrays have 0 as their lower bound, so <code>v</code> has six elements: <code>v</code>[0] to <code>v</code>[5].</p>
						<p class="fragment">The size of an array must be a <u>constant expression</u>.</p>
					</section>
					<section>
						<pre><code style="font-size:larger">int v[5] {1, 2, 3, 4, 5};

for(int i = 0; i < 5; ++i) {
    cout << v[i] << endl;
}
</code></pre>
						<pre class="fragment"><div class="output">1
2
3
4
5
</div></pre>
					</section>
					<section>
						<p>C++ also offers a simpler for-statement, called range-for-statement, for loops that traverse a sequence in the simplest way:</p>
						<pre class="fragment"><code style="font-size:larger">int v[5] {1, 2, 3, 4, 5};

for(auto x : v) {
    cout << x << endl;
}
</code></pre>
						<pre class="fragment"><div class="output">1
2
3
4
5
</div></pre>
					</section>
					<section>
						<pre><code style="font-size:larger">int v[5] {1, 2, 3, 4, 5};

for(auto x : v) {
    cout << x << endl;
}
</code></pre>			
						<p class="fragment">The range-<code>for</code>-statement can be read as "for every element of v, from the first to the last, place a copy in x and print it."</p>
						<p class="fragment">Note that we don’t have to specify an array bound when we initialize it with a list.</p>
						<p class="fragment">The range-<code>for</code>-statement can be used for any sequence of elements.</p>
					</section>
				</section>
				<section>
					<section>
						<h1>Pointers</h1>
						<p class="fragment">"<b>A pointer is a variable that contains the address of a variable</b>" [Kernighan and Ritchie, 1988, page 93]</p>
						<p class="fragment">The pointer is a mechanism for direct memory manipulation.</p>
						<p class="fragment">A pointer variable holds the address of an object.</p>
						<p class="fragment">When we say that a pointer is "<b>pointing to a certain object</b>", this means that the pointer variable is storing the memory address where the pointed object is.</p>
					</section>
					<section>
						<p>A pointer can be declared like this:</p>
						<pre class="fragment"><code style="font-size:larger">int* p;</code></pre>
						<p class="fragment">A pointer variable holds the address of an object of the appropriate type:</p>
						<pre class="fragment"><code style="font-size:larger">int* p = &v[4]; // p points to v's fifth element
int x = *p;     // *p is the object that p points to</code></pre>
						<span class="fragment"><img src="cpp/pointer.png" class="plain" width="30%"></span>
					</section>
					<section>
						<pre><code style="font-size:larger">int a = 27; // a = 27

int* p;
p = &a;     // p stores the address of a

cout << "Pointer p is storing " << p << " memory address" << endl;
cout << "Variable a is stored in " << &a << " memory address" << endl;
cout << "The content of variable pointed by p is " << *p << endl;
cout << "Since p pointer is also a variable, it is stored at " << &p << " memory address" << endl;</code></pre>
						<pre class="fragment"><div class="output">Pointer p is storing 0x7ff5fbff73c memory address
Variable a is stored in 0x7ff5fbff73c memory address
The content of variable pointed by p is 27
Since p pointer is also a variable, it is stored at 0x7ff5fbff730 memory address</div></pre>
						<span class="fragment"><img src="cpp/memoryAddresses.png" class="plain"></span>
					</section>
					<section>
						<pre><code style="font-size:larger">void swap(int a, int b)
{
    int aux = a;
    a = b;
    b = aux;
}

int main()
{
    int a = 3, b = 2;    
    cout << "Before swap: a = " << a << " b = " << b << endl;    
    swap(a, b);    
    cout << "After swap: a = " << a << " b = " << b << endl;    
}</code></pre>
						<pre class="fragment"><code class="output">Before swap: a = 3 b = 2
After swap a = 3 b = 2</code></pre>
					</section>
					<section>
						<pre><code style="font-size:larger">void swap(int *a, int *b)
{
    int aux = *a;
    *a = *b;
    *b = aux;
}

int main()
{
    int a = 3, b = 2;    
    cout << "Before swap: a = " << a << " b = " << b << endl;    
    swap(&a, &b);    
    cout << "After swap: a = " << a << " b = " << b << endl;    
}</code></pre>
						<pre class="fragment"><code class="output">Before swap: a = 3 b = 2
After swap a = 2 b = 3</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h1>Null Pointer: <code>nullptr</code></h1>
						<p class="fragment">We try to ensure that a pointer always points to an object, so that dereferencing it is valid.</p>
						<p class="fragment">When we don’t have an object to point to or if we need to represent the notion of ‘‘no object available’’ (e.g., for an end of a list), we give the pointer the value <code>nullptr</code> ("the null pointer").</p>
					</section>
					<section>
						<p>Thre is only one <code>nullptr</code> shared by all pointer types:</p>
						<pre class="fragment"><code style="font-size:larger">double* pd = nullptr;
Link&lt;Record&gt;* lst = nullptr; // pointer to a Link to a Record
int x = nullptr;             // error: nullptr is a pointer and not an integer</code></pre>
					</section>
					<section>
						<p>It is often wise to check that a pointer argument that is supposed to point to something, actually points to something:</p>
					<pre class="fragment"><code style="font-size:larger">int count_x(char* p, char x)
// count the number of occurrences of x in p[]
// p is assumed to point to a zero-terminated array of char (or to nothing)
{
    if (p==nullptr) return 0;
    int count = 0;
    for (; *p!=0; ++p)
        if (*p==x) ++count;
    return count;
}</code></pre>
						<p class="fragment">Note how we can move a pointer to point to the next element of an array using <code>++</code> and that we can leave out the initializer in a <code>for</code>-statement if we don’t need it.</p>
						<p class="fragment">The definition of <code>count_x</code> assumes that the <code>char*</code> is a C-style string, that is, that the pointer points to a zero-terminated array of <code>char</code>.</p>
						<p class="fragment">In older code, <code>0</code> or <code>NULL</code> is typically used instead of <code>nullptr</code>.</p>
						<p class="fragment">However, using <code>nullptr</code> eliminates potential confusion between integers (such as <code>0</code> or <code>NULL</code>) and pointers (such as <code>nullptr</code>).</p>
					</section>					
				</section>
				<section>
					<section>
						<h1>References</h1>
						<p class="fragment">In a declaration, the unary suffix <code>&</code> means "reference to".</p>
						<p class="fragment">A reference is similar to a pointer, except that you don’t need to use a prefix <code>*</code> to access the value referred by the reference.</p>
						<p class="fragment">Also, a reference cannot be made to refer to a different object after its initialization.</p>
					</section>
					<section>
						<p>References are particularly useful for specifying function arguments:</p>
						<pre class="fragment"><code style="font-size:larger">void sort(vector&lt;double&gt;& v);</code></pre>
						<p class="fragment">By using a reference, we ensure that for a call <code>sort(my_vec)</code>, we do not copy <code>my_vec</code> and that it really is my_vec that is sorted and not a copy of it.</p>
						<p class="fragment">When we don’t want to modify an argument, but still don’t want the cost of copying, we use a <code>const</code> reference:</p>
						<pre class="fragment"><code  style="font-size:larger">double sum(const vector&lt;double&gt;& v);</code></pre>
					</section>
					<section>
						<p>Recall this example:</p>
						<pre class="fragment"><code style="font-size:larger">int v[5] {1, 2, 3, 4, 5};

for(auto x : v) {
    cout << x << endl;
}</code></pre>
						<p class="fragment">If we didn’t want to copy the values from <code>v</code> into the variable <code>x</code>, but rather just have <code>x</code> refer to an element, we could write:</p>
						<pre class="fragment"><code style="font-size:larger">int v[5] {1, 2, 3, 4, 5};

for(auto& x : v) {
    cout << x << endl;
}</code></pre>
					</section>
					<section>
						<pre><code style="font-size:larger">int v[] = {0,1,2,3,4,5,6,7,8,9};
for (auto& x : v)
    ++x;

for(auto& x : v)
    cout << x << endl;
</code></pre>
					<pre class="fragment"><div class="output">1
2
3
4
5
6
7
8
9
10
</div></pre>
					</section>
					<section>
						<pre><code style="font-size:larger">void swap(int a, int b)
{
    int aux = a;
    a = b;
    b = aux;
}

int main()
{
    int a = 3, b = 2;    
    cout << "Before swap: a = " << a << " b = " << b << endl;    
    swap(a, b);    
    cout << "After swap: a = " << a << " b = " << b << endl;    
}
</code></pre>
					<pre class="fragment"><div class="output">before swap: a = 3 b = 2
After swap: a = 3 b = 2
</div></pre>
					</section>
										<section>
						<pre><code style="font-size:larger">void swap(int *a, int *b)
{
    int aux = *a;
    *a = *b;
    *b = aux;
}

int main()
{
    int a = 3, b = 2;    
    cout << "Before swap: a = " << a << " b = " << b << endl;    
    swap(&a, &b);    
    cout << "After swap: a = " << a << " b = " << b << endl;    
}
</code></pre>
					<pre class="fragment"><div class="output">before swap: a = 3 b = 2
After swap: a = 2 b = 3
</div></pre>
					</section>
										<section>
						<pre><code style="font-size:larger">void swap(int &a, int &b)
{
    int aux = a;
    a = b;
    b = aux;
}

int main()
{
    int a = 3, b = 2;    
    cout << "Before swap: a = " << a << " b = " << b << endl;    
    swap(a, b);    
    cout << "After swap: a = " << a << " b = " << b << endl;    
}
</code></pre>
					<pre class="fragment"><div class="output">before swap: a = 3 b = 2
After swap: a = 2 b = 3
</div></pre>
					</section>
				</section>
				<section>
						<h1>User-Defined Types</h1>
						<p class="fragment">The types that can be built from the fundamental types, the const modifier, and the declarator operators are the <b><u>built-in types</u></b>.</p>
						<p class="fragment">C++’s set of built-in types and operations is rich, but deliberately low-level.</p>
						<p class="fragment"> They don’t provide the programmer with high-level facilities to conveniently write advanced applications.</p>
						<p class="fragment">Instead, C++ augments the built-in types and operations with a sophisticated set of abstraction mechanisms out of which programmers can build such high- level facilities.</p>
						<p class="fragment">The C++ abstraction mechanisms are primarily designed to let programmers design and implement their own types, with suitable representations and operations, and for programmers to simply and elegantly use such types.</p>
						<p class="fragment">Types built out of the built-in types using C++’s abstraction mechanisms are called user-defined types.</p>
						<p class="fragment">They are referred to as <b>classes</b> and <b>enumerations</b>.</p>
				</section>
				<section>
					<section>
						<h1>Structures</h1>
						<p class="fragment">The first step to build a new type is often to organize the elements it need into a data structure, a struct:</p>
						<pre class="fragment"><code style="font-size:larger">struct Player {
    string name;
    int hp;
};
</code></pre>
						<p class="fragment">This is the structure definition for what makes a Player object.</p>
						<p class="fragment">The player has a <code>string</code> for his <code>name</code> and an <code>integer</code> for his hp <code>value</code>.</p>
					</section>
					<section>
						<pre><code style="font-size:larger">struct Player {
    string name;
    int hp;
};

int main()
{
    Player me; // create an instance of the Player, called me
    
    // from here, we can access the fields of the me object, like so:
    me.name = "Peter";
    me.hp = 100;   
}
</code></pre>
					</section>
					<section>
						<p class="fragment">We use <code>.</code> (dot) to access struct members through a name (and through a reference) and <code>-></code> to access <code>struct</code> members through a pointer:</p>
						<pre class="fragment"><code style="font-size:larger">void func(Player p, Player& rp, Player* pp)
{
    int i1 = p.hp;
    int i2 = rp.hp;
    int i3 = pp->hp;
}</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h1>Classes</h1>
						<p class="fragment">A set of <b>members</b>:</p>
						<ul>
							<li class="fragment">data</li>
							<li class="fragment">function</li>
							<li class="fragment">type members</li>
						</ul>
						<p class="fragment">Interface is defined by the <code>public</code> members</p>
						<p class="fragment"><code>private</code> members are accessible only through that interface</p>
					</section>
					<section>
						<pre><code style="font-size:larger">class Vector {
public:
    Vector (int s): elem{new double[s]}, sz{s} {} // construct a Vector
    double &operator[](int i) {return elem[i];}
    int size(){return sz;}
private:
    double *elem; // pointer to the elements
    int sz;       // the number of elements
};
</code></pre>
						<p class="fragment">We can define a variable of type <code>Vector</code>:</p>
						<pre class="fragment"><code style="font-size:larger">Vector v(6);</code></pre>
						<span class="fragment"><img class="plain" src="cpp/Vector6.png" width="80%"></span>
					</section>
					<section>
						<img class="plain" src="cpp/Vector6.png" width="80%">
						<p class="fragment">The vector object is a "handle" containing a pointer to the elements (<code>elem</code>) plus the number of elements (<code>sz</code>).</p>			
						<p class="fragment">The number of elements can vary from <code>Vector</code> object to <code>Vector</code> object.</p>			
						<p class="fragment">However, the <code>Vector</code> object itself is always the same size. </p>			
						<p class="fragment">This is the basic technique for handling varying amounts of information in C++: a fixed-size handle referring to a variable amount of data "elsewhere".</p>			
					</section>
					<section>
						<pre><code style="font-size:larger">class Vector {
public:
    Vector (int s): elem{new double[s]}, sz{s} {} // construct a Vector
    double &operator[](int i) {return elem[i];}
    int size(){return sz;}
private:
    double *elem; // pointer to the elements
    int sz;       // the number of elements
};
</code></pre>
						<p class="fragment"><code>Vector (int)</code> defines how objects of type <code>Vector</code> are constructed.</p>
						<p class="fragment">In particular, it states that it needs an integer to do that.</p>
						<p class="fragment">That integer is used as the number of elements.</p>
						<p class="fragment">The constructor initializes the <code>Vector</code> members using a member initializer list:</p>
						<pre class="fragment"><code style="font-size:larger">elem{new double[s]}</code></pre>
						<p class="fragment">That is, we first initialize elem with a pointer to s elements of type <code>double</code> manually allocated.</p>
						<p class="fragment">Then, we initialize <code>sz</code> to <code>s</code>.</p>
					</section>
					<section>
						<pre><code style="font-size:larger">class Vector {
public:
    Vector (int s): elem{new double[s]}, sz{s} {} // construct a Vector
    double &operator[](int i) {return elem[i];}
    int size(){return sz;}
private:
    double *elem; // pointer to the elements
    int sz;       // the number of elements
};
</code></pre>
						<p class="fragment">Access to elements is provided by a subscript function, called <code>operator[]</code>.</p>
						<p class="fragment">It returns a reference to the appropriate element (a <code>double&</code>). </p>
						<p class="fragment">The <code>size()</code> function is supplied to give users the number of elements. </p>
						<p class="fragment">There is no error handling.</p>
						<p class="fragment">There is no mechanism to free the array of doubles acquired by <code>new</code>.</p>
					</section>
					<section>
						<pre><code style="font-size:larger">class Vector {
public:
    Vector (int s): elem{new double[s]}, sz{s} {} // construct a Vector
    double &operator[](int i) {return elem[i];}
    int size(){return sz;}
private:
    double *elem; // pointer to the elements
    int sz;       // the number of elements
};
</code></pre>
						<pre class="fragment"><code style="font-size:larger">double read_and_sum(int s) {
    Vector v(s);                          // make a vector of s elements
    for (int i=0; i!=v.size(); ++i)
        cin>>v[i];                        // read into elements
    double sum = 0;
    for (int i=0; i!=v.size(); ++i)
        sum+=v[i];                        // take the sum of the elements
    return sum;
}
</code></pre>
					</section>
					<section>
						<p class="fragment">There is no fundamental difference between a <code>struct</code> an a <code>class</code>.</p>
						<p class="fragment">A <code>struct</code> is simply a <code>class</code> with members <code>public</code> by default.</p>
						<p class="fragment">You can define constructors and other member functions for a <code>struct</code>.</p>
					</section>
				</section>
				<section>
					<section>
						<h1>Enumerations</h1>
						<p class="fragment">Besides classes, C++ also supports a simple form of user-defined type for enumerating values:</p>
						<pre class="fragment"><code style="font-size:larger">enum class Color{red, blue, green};
enum class Traffic_light {green, yellow, red};

Color col = Color::red;
Traffic_light light = Traffic_light::red;</code></pre>
						<p class="fragment">Note that enumerators (e.g., <code>red</code>) are in the scope of their <code>enum class</code>.</p>
						<p class="fragment">This way, they can be used repeatedly in different <code>enum classes</code> without confusion.</p>
						<p class="fragment">For example, <code>Color::red</code> is <code>Color</code>’s <code>red</code> which is different from <code>Traffic_light::red</code>.</p>
					</section>
					<section>
						<p class="fragment">Enumerations are used to represent small sets of integer values.</p>
						<p class="fragment">They are used to make code more readable and less error-prone than it would have been had the symbolic (and mnemonic) enumerator names not been used. </p>
						<p class="fragment">The <code>class</code> after the <code>enum</code> specifies that an enumeration is strongly typed and that its enumerators are scoped.</p>
						<p class="fragment">Being separate types, <code>enum classes</code> help prevent accidental misuses of constants.</p>
						<p class="fragment">In particular, we cannot mix <code>Color</code> and <code>Traffic_light</code> values:</p>
						<pre class="fragment"><code style="font-size:larger">Color x = red;                // error : which red?
Color y = Traffic_light::red; // error: that red is not a Color
Color z = Color::red;         // OK
</code></pre>
					</section>
					<section>
						<p class="fragment">Similarly, it is not possible to mix <code>Color</code> and <code>integer</code> values:</p>
						<pre class="fragment"><code style="font-size:larger">int i = Color::red; // error: Color::red is not an int
Color c = 2;        // error: 2 is not a Color
</code></pre>
						<p class="fragment">If you don’t want to explicitly qualify enumerator names and want enumerator values to be ints (without the need for an explicit conversion), you can remove the class from enum class to get a "plain enum". </p>
						<p class="fragment">By default, an enum class has only assignment, initialization, and comparisons (e.g., == and <) defined.</p>
						<p class="fragment">However, an enumeration is a user-defined type so we can define operators for it:</p>
						<pre class="fragment"><code style="font-size:larger">Traffic_light& operator++(Traffic_light& t)
 	// prefix increment ++
{
    switch(t) {
        case Traffic_light::green : return t = Traffic_light::yellow;
        case Traffic_light::yellow : return t = Traffic_light::red;
        case Traffic_light::red : return t = Traffic_light::green;
    }
}

Traffic_light light = Traffic_light::red;
Traffic_light next = ++light; // next becomes Traffic_light::green
</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h1>Unions</h1>
						<p class="fragment">A <code>union</code> is a <code>struct</code> where all members are allocated at the same memory address.</p>
						<p class="fragment">The <code>union</code> occupies only the necessary space to store its largest member.</p>
						<p class="fragment">It only holds a value for one member at a time.</p>
					</section>
					<section>
						<p class="fragment">Consider the following example:</p>
						<pre class="fragment"><code style="font-size:larger">enum Type {str, num};

struct Entry {
    char *name;
    Type t;
    char *s;    // use s if t == str
    int i;      // use i if t == num
};

void f(Entry* p)
{
    if(p-&gt;t == str)
        cout &lt;&lt; p-&gt;s;
    // ...
}</code></pre>
						<p class="fragment">The members <code>s</code> and <code>i</code> can never be used at same time, so memory space is wasted.</p>
						<p class="fragment">This can be easily recovered by specifying that both should be member of an <code>union</code>.</p>
					</section>
					<section>
						<pre><code style="font-size:larger">union Value {
    char *s;
    int i;
};</code></pre>
						<p class="fragment">The language doesn’t keep track of which kind of value is held by a <code>union</code>.</p>
						<p class="fragment">Therefore, the programmer must do the following:</p>
						<pre class="fragment"><code style="font-size:larger">enum Type {str, num};

struct Entry {
    char *name;
    Type t;
    Value v; // use v.s if t == str; use v.i if t == num
};

void f(Entry* p)
{
    if(p-&gt;t == str)
        cout &lt;&lt; p-&gt;v.s;
    // ...
}</code></pre>
					</section>
					<section>
						<p class="fragment">Maintaining the correspondence between a type field and the type held in an <code>union</code> is error-prone.</p>
						<p class="fragment">To avoid errors, you should encapsulate an <code>union</code> so that the correspondence between a type field and access to the <code>union</code> members is guaranteed.</p>
						<p class="fragment">At the application level, abstractions relying on such <b>tagged unions</b> are common and useful.</p>
						<p class="fragment">However, the use of "naked" <code>unions</code> is best minimized.</p>
					</section>
				</section>
				<section>
					<section>
						<h1>Modularity</h1>
						<p class="fragment">A C++ program consists of <b>functions</b>, <b>user-defined types</b>, <b>class</b><b> hierarchies</b> and <b>templates</b>.</p>
						<p class="fragment">The programmer should clearly define the interactions among those parts.</p>
						<p class="fragment">The first and most important step is to distinguish between the interface part and its implementation.</p>
						<p class="fragment">At the language level, C++ represents interfaces by declarations.</p>
						<p class="fragment">A declaration specifies all that’s needed to use a function or a type.</p>
					</section>
					<section>
						<pre><code style="font-size:larger">double sqrt(double);  // the square root of function takes a double and returns a double

class Vector{
public:
    Vector(int s);
    double& operator[](int i);
    int size();
private:
    double* elem;  // elem points to an array of sz doubles
    int sz;
};</code></pre>
						<p class="fragment">The key point here is that the function bodies and the function definitions are in separate locations.</p>
						<pre class="fragment"><code style="font-size:larger">double sqrt(double d) // definition of sqrt
{
// ...  algorithm is found in math textbook
}</code></pre>
						<pre class="fragment"><code style="font-size:larger">Vector::Vector(int s)		// definition of the constructor
  :elem{new double[s]}, sz{s} 	// initialize members
{
}

double& Vector::operator[](int i) {
    return elem[i];		// definition of subscripting
}

int Vector::size() {
    return sz;
}</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h1>Separate compilation</h1>
						<p class="fragment">C++ supports a notion of separate compilation where user code sees only declarations of types and functions used.</p>
						<p class="fragment">The definitions of those types and functions are in separate source files and compiled separately.</p>
						<p class="fragment">This can be used to organize a program into a set of semi-independent code fragments.</p>
						<p class="fragment">Such separation can be used to minimize compilation times and to strictly enforce separation of logically distinct parts of a program (thus, minimizing the chance of errors).</p>
						<p class="fragment">A library is often a separately compiled code fragments (e.g., functions). </p>
						<p class="fragment">Typically, we place the declarations that specify the interface to a module in a file with a name indicating its intended use.</p>
					</section>
					<section>
						<pre class="fragment"><code style="font-size:larger">// Vector.hpp:
class Vector {
    public:
        Vector(int s);
        double& operator[](int i);
        int size();
    private:
        double* elem; // elem points to an array of sz doubles
        int sz;
};</code></pre>
					<pre class="fragment"><code style="font-size:larger">// user.cpp:
#include "Vector.hpp"	// get Vector’s interface
#include &lt;cmath&gt;	// get the the standard-library math function interface including sqrt()
using namespace std;	// make std members visible

double sqrt_sum(Vector& v) {
    double sum = 0;
    for (int i=0; i!=v.size(); ++i) // sum of square roots
        sum+=sqrt(v[i]);
    return sum;
}</code></pre><pre class="fragment"><code style="font-size:larger">// Vector.cpp:
#include "Vector.hpp" // get the interface

Vector::Vector(int s)
:elem{new double[s]}, sz{s}
{
}
double& Vector::operator[](int i)
{
    return elem[i];
}
int Vector::size()
{
    return sz;
}</code></pre>
					</section>
					<section>
						<p class="fragment">The code in <code>user.cpp</code> and <code>Vector.cpp</code> shares the Vector interface information presented in <code>Vector.hpp</code>, but the two files are otherwise independent and can be separately compiled. </p>
						<p class="fragment">Graphically, the program fragments can be represented like this:</p>
						<span class="fragment"><img src="cpp/separateCompilation.png" class="plain" width="80%"></span>
					</section>
				</section>
				<section>
					<h1>Namespaces</h1>
					<p class="fragment">In addition to functions, and enumerations, C++ offers <b>namespaces</b> as a mechanism for expressing that some declarations belong together and that their names shouldn’t conflict with other names.</p>
					<p class="fragment">The simplest way to access a name in another namespace is to qualify it with the namespace name (e.g., std::cout).</p>
					<p class="fragment">The <code>main()</code> function is defined in the global namespace, that is, not local to a defined namespace, class, or function.</p>
					<p class="fragment">To gain access to names in the standard-library namespace, we can use a using-directive:</p>
					<pre class="fragment"><code style="font-size:larger">using namespace std;</code></pre>
					<p class="fragment">Namespaces are primarily used to organize larger program components, such as libraries.</p>
					<p class="fragment">They simplify the composition of a program out of separately developed parts.</p>
				</section>
				<section>
						<h1>Error Handling</h1>
					</section>
				<section>					
					<section>
						<h1>Exceptions</h1>
						<p class="fragment">Consider again the <code>Vector</code> example.</p>
						<p class="fragment">What should be done when we try to access an element that is out of range for the vector from?</p>
						<ul>
							<li class="fragment">The writer of <code>Vector</code> doesn’t know what the user would like to have done in this case (the writer of <code>Vector</code> typically doesn’t even know in which program the vector will be running). </li>
							<li class="fragment">The user of <code>Vector</code> cannot consistently detect the problem (if the user could, the out-of-range access wouldn’t happen in the first place).</li>
						</ul>
						<p class="fragment">The solution is for the <code>Vector</code> implementer to detect the attempted out-of-range access and then tell the user about it.</p>
						<p class="fragment">The user can then take an appropriate action.</p>
						<p class="fragment">For example, <code>Vector::operator[]()</code> can detect an attempted out-of-range access and throw an out_of_range exception:</p>
						<pre class="fragment"><code style="font-size:larger">double& Vector::operator[](int i)
{
    if (i<0 || size()<=i) throw out_of_range{"Vector::operator[]"};
        return elem[i];
}</code></pre>
					</section>
					<section>
						<p class="fragment">The <code>throw</code> transfers control to a handler for exceptions of type <code>out_of_range</code> in some function that directly or indirectly called <code>Vector::operator[]()</code>.</p>
						<p class="fragment">To do that, the implementation will unwind the function call stack as needed to get back to the context of that caller.</p>
						<pre class="fragment"><code style="font-size:larger">void f(Vector& v)
{
    // ...
    try { 			// exceptions here are handled by the handler defined below
        v[v.size()] = 7; 	// try to access beyond the end of v
    }
    catch (out_of_range) { 	// oops: out_of_range error
        			// ... handle range error ...
    }
    // ...
}</code></pre>
					</section>
					<section>
						<p class="fragment">We put code for which we are interested in handling exceptions into a <code>try</code>-block.</p>
						<p class="fragment">That attempted assignment to <code>v[v.size()]</code> will fail.</p>
						<p class="fragment">Therefore, the <code>catch</code>-clause providing a handler for <code>out_of_range</code> will be entered.</p>
						<p class="fragment">The <code>out_of_range</code> type is defined in the standard library and is in fact used by some standard-library container access functions.</p>
						<p class="fragment">Use of the exception-handling mechanisms can make error handling simpler, more systematic, and more readable.</p>
					</section>
				</section>
				<section>
					<section>
						<h1>Invariants</h1>
						<p class="fragment">The use of exceptions to signal out-of-range access is an example of a function checking its argument and refusing to act because a basic assumption, a <b>precondition</b>, didn’t hold.</p>
						<p class="fragment">Had we formally specified Vector’s subscript operator, we would have said something like "<b>the index must be in the [0:size()) range</b>", and that was in fact what we tested in our operator[]().</p>
						<p class="fragment">Whenever we define a function, we should consider what its preconditions are and if feasible test them.</p>
					</section>
					<section>
						<p class="fragment">However, operator[]() operates on objects of type <code>Vector</code> and nothing it does makes any sense unless the members of <code>Vector</code> have "<b>reasonable</b>" values.</p>
						<p class="fragment">In particular, we did say "<b>elem points to an array of sz doubles</b>" but we only said that in a comment.</p>
						<p class="fragment">Such a statement of what <u>is assumed to be true for a class is called a</u> <b>class invariant</b>, or simply an <b>invariant</b>.</p>
						<p class="fragment">It is the job of a constructor to establish the invariant for its class (so that the member functions can rely on it) and for the member functions to make sure that the invariant holds when they exit.</p>
						<p class="fragment">Our <code>Vector</code> constructor only partially did its job: it properly initialized the <code>Vector</code> members, but it failed to check that the arguments passed to it made sense:</p>
						<pre class="fragment"><code style="font-size:larger">Vector v(-27);</code></pre>
					</section>
					<section>
						<pre class="fragment"><code style="font-size:larger">Vector::Vector(int s) {
   if (s<0) throw length_error{};
      elem = new double[s];
   sz = s;
}
</code></pre>
						<p class="fragment">We use the standard-library exception <code>length_error</code> to report a non-positive number of elements because some standard-library operations use that exception to report problems of this kind.</p>
						<p class="fragment">If operator new can’t find memory to allocate, it throws a <code>std::bad_alloc</code>.</p>
						<p class="fragment">This way, we can write:</p>
						<pre class="fragment"><code style="font-size:larger">void test() {
    try {
        Vector v(−27);
    }
    catch (std::length_error) {The static_assert mechanism can be used for anything that can be expressed in terms of constant expressions.
        // handle negative size
    }
    catch (std::bad_alloc) {
        // handle memory exhaustion
    }
}</code></pre>
					</section>
					<section>
						<p class="fragment">You can define your own classes to be used as exceptions and have them carry arbitrary information from a point where an error is detected to a point where it can be handled. </p>
						<p class="fragment">Often, a function has no way of completing its assigned task after an exception is thrown.</p>
						<p class="fragment">Then, “handling” an exception simply means doing some minimal local cleanup and rethrowing the exception.</p>
					</section>
				</section>
				<section>
					<section>
						<h1>Static Assertions</h1>
						<p class="fragment">Exceptions report errors found at run time.</p>
						<p class="fragment">If an error can be found at compile time, it is usually preferable to do so.</p>
						<p class="fragment">We can perform simple checks on properties that are known at compile time and report failures as compiler error messages:</p>
						<pre class="fragment"><code style="font-size:larger">static_assert(4<=sizeof(int), "integers are too small"); // check integer size</code></pre>
							<p class="fragment">This will write "<b>integers are too small</b>" <code>if 4<=sizeof(int)</code> does not hold, that is, if an int on this system does not have at least 4 bytes.</p>
							<p class="fragment">We call such statements of expectations <b>assertions</b>.</p>
					</section>
					<section>
						<p class="fragment">The static_assert mechanism can be used for anything that can be expressed in terms of constant expressions.</p>
						<pre class="fragment"><code style="font-size:larger">constexpr double C = 299792.458; // km/s

void f(double speed) {
    const double local_max = 160.0/(60∗60); // 160 km/h == 160.0/(60*60) km/s
    
    static_assert(speed&lt;C,"can't go that fast"); // error: speed must be a constant
    static_assert(local_max&lt;C,"can't go that fast"); // OK
    // ...
}</code></pre>
						<p class="fragment">In general, <code>static_assert(A,S)</code> prints <code>S</code> as a compiler error message if <code>A</code> is not <code>true</code>.</p>
						<p class="fragment">The most important uses of <code>static_assert</code> come when we make assertions about types used as parameters in generic programming.</p>
					</section>
				</section>


 





















				

			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				width: 1920,
				height: 1080,
				controls: true,
				progress: true,
				center: true,
				hash: true,
				transition: 'convex',
				math: {
					// mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full',
					TeX: {
						Macros: {
							R: '\\mathbb{R}',
							set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
						}
					}
				},
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },					
					{ src: 'plugin/highlight/highlight.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/math/math.js', async: true }
				]
			});
		</script>
	</body>
</html>
