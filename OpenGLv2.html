<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<title>OpenGL</title>

		<meta name="description" content="Computer Graphics - OpenGL">
		<meta name="author" content="Gustavo Reis">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/obsidian.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<img src="images/OpenGL/Opengl-logo.svg" width="100%" class="plain">
						<p><center><small>Source:</small></center></p>
						<p><center><small><a href="http://learnopengl.com">Learn OpenGL</a></small></center></p>
						<p><center><small><a href="http://open.gl">Open.GL</a></small></center></p>
				</section>
				<section>
					<section>
						<h1>OpenGL</h1>
						<p class="fragment">OpenGL® is the industry’s most widely adopted 2D and 3D graphics API, powering thousands of applications across a variety of computing platforms.</p>
						<p class="fragment">It is independent of windowing systems and operating systems, and is also network-transparent.</p>
					</section>
					<section>
						<h1>OpenGL</h1>
						<p class="fragment">OpenGL enables developers to create high-performance, visually compelling graphics applications on platforms ranging from PCs to supercomputers, across fields like CAD, content creation, energy, entertainment, game development, manufacturing, medical imaging, and virtual reality.</p>
						<p class="fragment">OpenGL gives developers full access to the latest features of modern graphics hardware.</p>
					</section>
				</section>
				<section>
					<section>
						<h3>Core Profile vs Immediate Mode</h3>
						<p class="fragment">In the early days of OpenGL, development was done using the fixed function pipeline, also known as immediate mode. This was an easy method for drawing graphics but lacked flexibility.</p>
						<p class="fragment">Much of OpenGL's inner workings were hidden, limiting developers' control over how graphics were processed.</p>
					</section>
					<section>
						<h3>Core Profile vs Immediate Mode</h3>
						<p class="fragment">As developers sought more flexibility, OpenGL's specifications evolved, giving developers more control over graphics rendering.</p>
						<p class="fragment">While immediate mode was easy to learn, it was also very inefficient, leading to its eventual deprecation.</p>
					</section>
					<section>
						<p class="fragment">Since version 3.2, OpenGL began deprecating immediate mode in favor of the more efficient core profile, which requires the use of modern practices and removes outdated functionality.</p>
						<p class="fragment">When developing with the core profile, using deprecated functions results in errors and no rendering.</p>
					</section>
					<section>
						<p class="fragment">Although the modern approach is more challenging to learn, it offers significantly more flexibility and efficiency, helping developers gain a deeper understanding of graphics programming.</p>
						<p class="fragment">Our classes focus on Core Profile OpenGL (version 3.3) because mastering this approach is well worth the effort.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Creating a Window and an OpenGL Context</h2>
						<p class="fragment">Before drawing anything, you need to initialize OpenGL by creating an OpenGL context. This context is a state machine that stores all rendering-related data for your application.</p>
						<p class="fragment">When the application closes, the OpenGL context is destroyed, cleaning up all resources.</p>
					</section>
					<section>
						<p class="fragment">Creating a window and OpenGL context isn’t specified in OpenGL, so the process differs across platforms.</p>
						<p class="fragment">OpenGL is designed for portability, so developers often use libraries that abstract this process, ensuring compatibility across different platforms.</p>
					</section>
					<section>
						<p class="fragment">While various libraries exist, they generally follow a similar flow: you first define window properties like title and size, as well as OpenGL context properties such as anti-aliasing settings.</p>
					</section>
					<section>
						<p class="fragment">Your application will then start the event loop, handling tasks like processing window events (e.g., mouse clicks), updating rendering state, and drawing objects.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Normalized Device Coordinates (NDC)</h2>
						<img src="images/OpenGL/c2_dc.png" class="plain" width="80%">
					</section>
					<section>
						<h2>Normalized Device Coordinates (NDC)</h2>
						<img src="images/OpenGL/c2_dc2.png" class="plain" width="80%">
					</section>
				</section>
				<section>
					<section>
						<h3>Setup</h3>
						<p class="fragment"><b>Windows</b>: Add <code>opengl32.lib</code> to your linker.</p>
						<p class="fragment"><b>Linux</b>: Add <code>-IGL</code> to your compiler options.</p>
						<p class="fragment"><b>OS X</b>: Add <code>-framework OpenGL</code> to your compiler options.</p>
					</section>
					<section>
						<h3>SDL 2</h3>
						<pre><code>#ifdef __APPLE__
#include &lt;SDL2/SDL.h&gt;
#elif _WIN32
#include &lt;SDL.h&gt;
#endif
int main(int argc, char** argv)
{
	SDL_Init(SDL_INIT_VIDEO);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
	SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
	SDL_Window* window = SDL_CreateWindow("OpenGL", 100, 100, 800, 600, SDL_WINDOW_OPENGL);
	SDL_GLContext context = SDL_GL_CreateContext(window);
	SDL_Event windowEvent;
	while (true)
	{
		if (SDL_PollEvent(&windowEvent))
		{
			if (windowEvent.type == SDL_QUIT) break;
		}
		SDL_GL_SwapWindow(window);
	}
	SDL_GL_DeleteContext(context);
	SDL_DestroyWindow(window);
	SDL_Quit();
	return 0;
}</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h3>OpenGL Context Creation</h3>
						<pre><code>
SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);

SDL_Window* window = SDL_CreateWindow("OpenGL", 100, 100, 800, 600, SDL_WINDOW_OPENGL);
SDL_GLContext context = SDL_GL_CreateContext(window);
</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h3>GLAD</h3>
						<p class="fragment">We’re not done yet! Because OpenGL is a specification, it’s up to the graphics driver manufacturers to implement it. However, the location of OpenGL functions may vary depending on the driver version.</p>
						<p class="fragment">This means OpenGL functions need to be queried at runtime, and stored for later use.</p>
					</section>
					<section>
						<p class="fragment">GLAD is an open-source library that handles all the tedious work of retrieving and managing these OpenGL function pointers for you.</p>
						<p class="fragment">You can configure GLAD through its web service to define and load all the relevant OpenGL functions for your specific version of OpenGL.</p>
						<pre class="fragment"><code>#include &lt;glad/glad.h&gt;</code></pre>
					</section>
				</section>
				<section>
					<section>
						<pre><code>// define the function's prototype
typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);
// find the function and assign it to a function pointer
GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)SDL_GL_GetProcAddress("glGenBuffers");
// function can now be called as normal
unsigned int buffer;
glGenBuffers(1, &buffer);
printf("%u\n", buffer);
</code></pre>
					</section>
				</section>
					<section>
						<pre><code>#include &lt;iostream&gt;
#include &lt;glad/glad.h&gt;
#ifdef __APPLE__
#include &lt;SDL2/SDL.h&gt;
#elif _WIN32
#include &lt;SDL.h&gt;
#endif
int main(int argc, char **argv)
{
	SDL_Init(SDL_INIT_VIDEO);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
	SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
	
	SDL_Window* window = SDL_CreateWindow("OpenGL", 100, 100, 800, 600, SDL_WINDOW_OPENGL);
	if(window == nullptr)
	{
		std::cout &lt;&lt; "Failed to create SDL Window" &lt;&lt; std::endl;
		SDL_Quit();
		return -1;
	}
	
	SDL_GLContext context = SDL_GL_CreateContext(window);
	
	if(!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress))
	{
		std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;
		SDL_Quit();
		return -2;
	}

	SDL_Event windowEvent;
	while (true)
	{
		if (SDL_PollEvent(&windowEvent))
		{
			if (windowEvent.type == SDL_QUIT) break;
		}

		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);
		SDL_GL_SwapWindow(window);
	}

	SDL_GL_DeleteContext(context);
	SDL_DestroyWindow(window);
	SDL_Quit();
	return 0;
}
</code></pre>		
					</section>
					<section><img src="images/OpenGL/screenshot.png" class="plain" width="70%">			
</section>
				</section>
				<section>
					<section>
						<h1>The Graphics Pipeline</h1>					
					</section> 
					<section>
						 <img src="images/OpenGL/c2_pipeline.png" class="plain" alt="Graphics Pipeline Overview"> <center><small>Image taken from: <a href="https://open.gl/drawing">https://open.gl/drawing</a></small></center> 
					</section> 
					<section>
						 <h2>Vertex Shader</h2> 
						 <p class="fragment">The vertex shader is the first programmable stage in the graphics pipeline. It processes individual vertices, applying transformations to convert 3D world coordinates into 2D screen coordinates.</p> 
						 <p class="fragment">This is where perspective transformations take place, projecting the 3D positions of vertices onto the 2D space of the screen.</p> 
						 <p class="fragment">Besides transforming the vertices, the vertex shader passes attributes such as color, texture coordinates, and normals down the pipeline.</p> 
					</section> 
					<section>
						 
						<p class="fragment">Once the vertices are processed, the graphics card groups them into primitives — the basic building blocks of rendering. These primitives can be triangles, lines, or points.</p> 
						 <p class="fragment">There are additional drawing modes, such as triangle strips or line strips, which reduce the number of vertices needed by connecting primitives continuously, like forming a connected line or mesh.</p> 
					</section> 
					<section>
						 <h2>Geometry Shader</h2> 
						 <p class="fragment">The geometry shader, an optional stage, was introduced more recently. Unlike the vertex shader, the geometry shader can output more vertices than it receives as input.</p> 
						 <p class="fragment">It operates on entire primitives, such as triangles or lines, and can modify, discard, or generate new primitives.</p> 
					</section> 
					<section>						 
						<p class="fragment">This stage can be especially useful when you want to minimize data transfers between the CPU and GPU. For example, in voxel games, you can pass only the positions of vertices, and the geometry shader can generate cubes or other shapes at runtime.</p> 
					</section> 
					<section>
						 <h2>Fragment Shader</h2> 
						 <p class="fragment">After the vertices and primitives are processed, the fragment shader handles the per-pixel operations.</p> 
						 <p class="fragment">The rasterizer converts the visible parts of primitives into pixel-sized fragments. The interpolated attributes from the vertex shader (or geometry shader) are passed to the fragment shader for each fragment.</p> 
						 <p class="fragment">For instance, in a triangle, even though you only specified color at three vertices, the colors across the triangle’s surface are smoothly interpolated.</p> 
						</section> 
					<section>						 
						<p class="fragment">The fragment shader calculates the final color of each fragment by using inputs such as texture coordinates, lighting calculations, and more. It’s also responsible for performing advanced effects like lighting, shadowing, and texture mapping.</p> 
					</section> 
					<section>						 
						<p class="fragment">Additionally, the fragment shader can discard fragments, making certain parts of the shape transparent or see-through. This is especially useful when rendering objects like windows or glass.</p> 
						 <p class="fragment">The final output of the fragment shader is passed through depth and stencil testing stages, where the GPU determines which fragments should be visible based on depth or stencil rules.</p> 
						</section> 
					<section>						 
						<p class="fragment">The main takeaway from depth and stencil testing is that they allow the GPU to decide which fragments are visible based on their relative position. For example, a fragment of a triangle closer to the camera will obscure fragments from triangles farther away.</p> 
					</section> </section>
				
					<section>
						<section>
							<h1>Hello Triangle</h1>
						</section>
						
						<section>
							<h2>Vertex Input</h2>
							<p class="fragment">To start drawing something, we first need to provide OpenGL with input vertex data.</p>
							<p class="fragment">OpenGL is a 3D graphics library, meaning all coordinates we specify are in 3D (x, y, and z coordinates).</p>
							<p class="fragment">However, OpenGL only processes 3D coordinates that are within a specific range:</p>
							<ul class="fragment">
								<li>Coordinates must be between -1.0 and 1.0 on all three axes (x, y, and z) to be visible on the screen.</li>
							</ul>
						</section>
						
						<section>
							<p class="fragment">Coordinates within this <strong>normalized device coordinates (NDC)</strong> range are rendered on the screen, while those outside are discarded.</p>
							<p class="fragment">To render a triangle, we need to define three vertices with 3D positions:</p>
							<pre class="fragment"><code>float vertices[] = {
  0.0f,  0.5f,  // Vertex 1 (X, Y)
  0.5f, -0.5f,  // Vertex 2 (X, Y)
 -0.5f, -0.5f   // Vertex 3 (X, Y)
};</code></pre>
						</section>
						
						<section>
							<h2>Normalized Device Coordinates (NDC)</h2>
							<p class="fragment">Once processed by the vertex shader, vertex coordinates are transformed into normalized device coordinates, where the x, y, and z values range from -1.0 to 1.0.</p>
							<p class="fragment">Any coordinates outside this range are clipped and not visible on the screen.</p>
						</section>
						
						<section>
							<p class="fragment">The following image illustrates the triangle in normalized device coordinates:</p>
							<p class="fragment"><img class="plain" src="images/OpenGL/ndc.png" width="100%" alt="Triangle in NDC"></p>
						</section>
						
						<section>
							<p class="fragment">With the vertex data defined, we send it as input to the first process of the graphics pipeline: the vertex shader.</p>
							<p class="fragment">This involves creating memory on the GPU to store the vertex data, configuring OpenGL to interpret the memory, and specifying how the data is sent to the graphics card.</p>
						</section>
						
						<section>
							<p class="fragment">We use <strong>Vertex Buffer Objects (VBOs)</strong> to store a large number of vertices in the GPU’s memory. The advantage is that we can send large batches of data all at once, avoiding the overhead of sending one vertex at a time.</p>
							<p class="fragment">The vertex shader processes vertices directly from the GPU memory, making this process extremely fast.</p>
						</section>
						
						<section>
							<p class="fragment">VBOs are OpenGL objects, identified by unique IDs. We generate a buffer ID using the <code>glGenBuffers</code> function:</p>
							<pre class="fragment"><code>GLuint vbo;
glGenBuffers(1, &vbo); // Generate 1 buffer</code></pre>
						</section>
						
						<section>
							<p class="fragment">After generating the buffer, we bind it to the <code>GL_ARRAY_BUFFER</code> target:</p>
							<pre class="fragment"><code>glBindBuffer(GL_ARRAY_BUFFER, vbo);</code></pre>
							<p class="fragment">Once bound, any operations on <code>GL_ARRAY_BUFFER</code> will apply to this buffer.</p>
						</section>
						
						<section>
							<p class="fragment">We can now copy the vertex data into the buffer's memory using the <code>glBufferData</code> function:</p>
							<pre class="fragment"><code>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code></pre>
						</section>
						
						<section>
							<p class="fragment"><code>glBufferData</code> takes the following arguments:</p>
							<ul class="fragment">
								<li>The buffer target (in this case, <code>GL_ARRAY_BUFFER</code>).</li>
								<li>The size of the data being passed (using <code>sizeof(vertices)</code>).</li>
								<li>The actual vertex data to store in the buffer.</li>
								<li>A usage hint to tell the GPU how we intend to use this data (e.g., <code>GL_STATIC_DRAW</code>, <code>GL_DYNAMIC_DRAW</code>, or <code>GL_STREAM_DRAW</code>).</li>
							</ul>
							<p class="fragment">Since the vertex data will rarely change, we use <code>GL_STATIC_DRAW</code> for optimal performance.</p>
						</section>
						
						<section>
							<h2>Vertex Shader</h2>
							<p class="fragment">The <strong>vertex shader</strong> processes each vertex and its attributes from the vertex buffer. Its role is to output the final vertex position in device coordinates and pass relevant data to the fragment shader.</p>
							<pre class="fragment"><code>#version 330 core
layout (location = 0) in vec2 position;
void main()
{
	gl_Position = vec4(position, 0.0, 1.0);
}</code></pre>
							<p class="fragment">This GLSL (OpenGL Shading Language) shader takes a 2D position as input and sets the <code>gl_Position</code> to output the position in 3D space.</p>
						</section>
						
						<section>
							<h2>Fragment Shader</h2>
							<p class="fragment">The <strong>fragment shader</strong> determines the color of each pixel (or fragment) that makes up the shapes drawn on the screen. For now, the fragment shader will output a fixed color:</p>
							<pre class="fragment"><code>#version 330 core
out vec4 outColor;
void main()
{
	outColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);  // Orange color
}</code></pre>
						</section>
						<section>
							<h2>Compiling Shaders</h2>
							<p class="fragment">To use shaders in OpenGL, we first need to compile them at runtime. Let's start with the vertex shader.</p>
							<p class="fragment">We write the vertex shader source code as a string, and OpenGL dynamically compiles it:</p>
							<pre class="fragment"><code>const char* vertexShaderSource = R"glsl(
#version 330 core
layout (location = 0) in vec2 position;
void main()
{
	gl_Position = vec4(position, 0.0, 1.0);
}
)glsl";</code></pre>
						</section>
						
						<section>
							<p class="fragment">To compile the shader, we first create a shader object, attach the source code to it, and compile it:</p>
							<pre class="fragment"><code>GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER); // Create a vertex shader
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL); // Attach the shader source code
glCompileShader(vertexShader); // Compile the shader</code></pre>
						</section>
						
						<section>
							<p class="fragment">It's important to check whether the shader compiled successfully. If not, we can retrieve the error message using the following code:</p>
							<pre class="fragment"><code>GLint success;
char infoLog[512];
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
if (!success)
{
	glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
	std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
}</code></pre>
						</section>
						
						<section>
							<p class="fragment">The fragment shader is compiled in a similar manner:</p>
							<pre class="fragment"><code>const char* fragmentShaderSource = R"glsl(
#version 330 core
out vec4 outColor;
void main()
{
	outColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);  // Orange color
}
)glsl";

GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); // Create a fragment shader
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL); // Attach the shader source code
glCompileShader(fragmentShader); // Compile the shader</code></pre>
						</section>
						
						<section>
							<p class="fragment">Similarly, you should check for errors after compiling the fragment shader:</p>
							<pre class="fragment"><code>glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
if (!success)
{
	glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
	std::cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << std::endl;
}</code></pre>
						</section>
						
						<section>
							<h2>Linking Shaders into a Shader Program</h2>
							<p class="fragment">After compiling the shaders, we need to link them into a shader program. First, create a program object:</p>
							<pre class="fragment"><code>GLuint shaderProgram = glCreateProgram();</code></pre>
						</section>
						
						<section>
							<p class="fragment">Next, attach the compiled vertex and fragment shaders to the program and link them:</p>
							<pre class="fragment"><code>glAttachShader(shaderProgram, vertexShader);  // Attach the vertex shader
glAttachShader(shaderProgram, fragmentShader);  // Attach the fragment shader
glLinkProgram(shaderProgram);  // Link the shader program</code></pre>
						</section>
						
						<section>
							<p class="fragment">Again, it's a good idea to check if linking was successful:</p>
							<pre class="fragment"><code>glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
if (!success)
{
	glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
	std::cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl;
}</code></pre>
						</section>
						
						<section>
							<p class="fragment">Once the shaders are linked into the program, we no longer need the individual shader objects, so they can be deleted:</p>
							<pre class="fragment"><code>glDeleteShader(vertexShader); // Delete the vertex shader
glDeleteShader(fragmentShader); // Delete the fragment shader</code></pre>
						</section>
						
						<section>
							<p class="fragment">Now, the <code>shaderProgram</code> contains the linked shaders, and we can use it in our render loop by calling:</p>
							<pre class="fragment"><code>glUseProgram(shaderProgram);</code></pre>
						</section>
						<section>
							<h3>Linking Vertex Attributes</h3>
							<p class="fragment">After creating the shaders, OpenGL needs to know how to interpret the vertex data in memory and how to link this data to the vertex shader's attributes.</p>
							<p class="fragment">This step involves linking the vertex data to the attributes declared in the vertex shader. In this case, we need to link the position attribute.</p>
						</section>
						
						<section>
							<p class="fragment">First, we define the vertex data (positions of the triangle) in an array:</p>
							<pre class="fragment"><code>float vertices[] = {
	0.0f,  0.5f,  // Vertex 1 (X, Y)
	0.5f, -0.5f,  // Vertex 2 (X, Y)
	-0.5f, -0.5f   // Vertex 3 (X, Y)
};</code></pre>
							<p class="fragment"><img src="images/OpenGL/stride.png" class="plain"></p>
						</section>
						
						<section>
							<img src="images/OpenGL/stride.png" class="plain" width="60%">
							<p class="fragment">The position attribute is stored as two floating point values per vertex, representing the X and Y coordinates. We will link this data to the <code>position</code> attribute in the vertex shader.</p>
							<p class="fragment">The position data is stored as 32-bit (4 byte) floating point values.</p>
							<p class="fragment">Each position is composed of 2 of those values.</p>
							<p class="fragment">There is no space (or other values) between each set of 2 values. The values are tightly packed in the array.</p>
							<p class="fragment">The first value in the data is at the beginning of the buffer.</p>
						</section>
						
						<section>
							<p class="fragment">To link the vertex data to the vertex attribute, we use the <code>glVertexAttribPointer</code> function:</p>
							<pre class="fragment"><code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);</code></pre>
						
						</section>
						
						<section>
							<pre><code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);</code></pre>
							<p class="fragment">Let’s break down the parameters of <code>glVertexAttribPointer</code>:</p>
							<ul class="fragment">
								<li><b>0</b>: The index of the vertex attribute. We specified the position attribute to have location 0 in the vertex shader using <code>layout (location = 0)</code>.</li>
								<li><b>2</b>: The number of components per vertex attribute. Each position consists of two components: X and Y.</li>
								<li><b>GL_FLOAT</b>: The data type of each component, which is <code>float</code>.</li>
							</ul>
						</section>

						<section>
							<pre><code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);</code></pre>
							<ul class="fragment">
								<li><b>GL_FALSE</b>: Whether the data should be normalized. We set this to false because the data is already in the correct format.</li>
								<li><b>2 * sizeof(float)</b>: The stride, which specifies the byte offset between consecutive vertex attributes. Since each vertex consists of two floats (X and Y), the stride is <code>2 * sizeof(float)</code>.</li>
								<li><b>(void*)0</b>: The offset of the first component of the attribute in the array. Here, it is <code>0</code> since the position attribute is the first data in the array.</li>
							</ul>
						</section>
						
						<section>
							<p class="fragment">After specifying the layout of the vertex data, we enable the vertex attribute at location 0 using:</p>
							<pre class="fragment"><code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);</code></pre>
						</section>
						
						<section>
							<p class="fragment">Once linked, the vertex attribute configuration is stored in a Vertex Array Object (VAO). You only need to specify this configuration once, and OpenGL will remember it.</p>
						</section>
						
						<section>
							<p class="fragment">This setup ensures that when we render our objects, the vertex data is correctly linked to the position attribute in the vertex shader.</p>
						</section>
						<section>
							<h3>Vertex Array Object (VAO)</h3>
							<p class="fragment">In OpenGL, a Vertex Array Object (VAO) stores the configuration of the vertex attributes and the buffers associated with them. This allows you to set up vertex attributes once and reuse them during rendering.</p>
						</section>
						
						<section>
							<p class="fragment">A VAO can be bound just like any buffer object, and any vertex attribute calls made after binding the VAO will be stored in it.</p>
						</section>
						
						<section>
							<p class="fragment">This is how we generate and bind a VAO:</p>
							<pre class="fragment"><code>GLuint vao;
glGenVertexArrays(1, &vao);
glBindVertexArray(vao);</code></pre>
						</section>
						
						<section>
							<p class="fragment">The <code>glGenVertexArrays</code> function generates a VAO, and <code>glBindVertexArray</code> makes it the current active VAO. All subsequent vertex attribute calls will be stored in this VAO.</p>
						</section>
						
						<section>
							<p class="fragment">Next, we bind the VBO and configure the vertex attributes as shown in the previous sections:</p>
							<pre class="fragment"><code>// 1. Bind the VAO
glBindVertexArray(vao);

// 2. Copy the vertex data into a VBO
glBindBuffer(GL_ARRAY_BUFFER, vbo);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

// 3. Set up the vertex attribute pointers
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);</code></pre>
						</section>
						
						<section>
							<p class="fragment">At this point, we have stored the vertex data configuration (using VBO) and vertex attribute pointers (using <code>glVertexAttribPointer</code>) inside the VAO. Now, we can unbind the VAO to avoid accidentally modifying it:</p>
							<pre class="fragment"><code>glBindVertexArray(0);</code></pre>
						</section>
						
						<section>
							<p class="fragment">When we want to render an object, we simply bind the VAO, and OpenGL will automatically use the stored configuration:</p>
							<pre class="fragment"><code>// Bind the VAO before drawing
glBindVertexArray(vao);
glDrawArrays(GL_TRIANGLES, 0, 3);
glBindVertexArray(0);</code></pre>
						</section>
						
						<section>
							<p class="fragment">By binding the VAO, OpenGL automatically uses the associated vertex attributes and buffers. This allows you to efficiently switch between different objects by simply binding different VAOs.</p>
						</section>
						
						<section>
							<p class="fragment">The VAO stores the following information:</p>
							<ul class="fragment">
								<li>Vertex attribute configurations such as <code>glVertexAttribPointer</code> calls</li>
								<li>Enabled/disabled state of vertex attributes via <code>glEnableVertexAttribArray</code></li>
								<li>Which VBOs are associated with which vertex attributes</li>
							</ul>
						</section>
						
						<section>
							<p class="fragment"><b>Important Note:</b></p>
							<ul class="fragment">
								<li>In OpenGL's core profile, using a VAO is mandatory for rendering objects. Failing to bind a VAO will result in nothing being drawn.</li>
							</ul>
						</section>
						
						<section>
							<img src="images/OpenGL/vao.png" class="plain" width="70%">
						</section>
						
						<section>
							<p class="fragment">In summary, the VAO encapsulates the state of all the vertex attribute configurations and buffer associations, allowing for efficient rendering of different objects by switching VAOs.</p>
						</section>
						
						<section>
							<h2>Drawing the Triangle</h2>
							<p class="fragment">After configuring vertex and fragment shaders, we can now draw our triangle using the <code>glDrawArrays</code> function:</p>
							<pre class="fragment"><code>glUseProgram(shaderProgram);
glBindVertexArray(vao);
glDrawArrays(GL_TRIANGLES, 0, 3);</code></pre>
							<p class="fragment">The function draws 3 vertices starting at index 0 as a triangle.</p>
						</section>
						
						<section>
							<img src="images/OpenGL/orange_triangle.png" class="plain" width="70%" alt="Orange Triangle">
						</section>
						
						<section>
							<h2>Uniforms</h2>
							<p class="fragment">We can also change the color of the triangle after compiling the shader by using <strong>uniforms</strong>, which are global variables available in shaders. Here's how we modify the triangle's color dynamically:</p>
							<pre class="fragment"><code>#version 330 core
uniform vec3 triangleColor;
out vec4 outColor;
void main()
{
	outColor = vec4(triangleColor, 1.0);
}</code></pre>
						</section>
						
						<section>
							<p class="fragment">You can update the uniform value in your C++ code by retrieving the uniform location and setting its value with <code>glUniform</code> functions:</p>
							<pre class="fragment"><code>GLint uniColor = glGetUniformLocation(shaderProgram, "triangleColor");
glUniform3f(uniColor, 1.0f, 0.0f, 0.0f);  // Red color</code></pre>
							<p class="fragment">This will change the triangle's color to red.</p>
						</section>
						
						<section>
							<img src="images/OpenGL/red_triangle.png" width="65%" class="plain" alt="Red Triangle">
						</section>
					</section>

					<section>
						<p class="fragment">To make things a little more exciting, try varying the color with the time by doing something like this in your main loop:</p>
						<pre class="fragment"><code>int start = SDL_GetTicks();

[...]

int now = SDL_GetTicks();
float time = (now-start) / 1000.0f;
glUniform3f(uniColor, (sin(time * 4.0f) + 1.0f) / 2.0f, 0.0f, 0.0f);</code></pre>
					</section>
				</section>
				<section>
					<section><h1>Adding Some more Colors</h1></section>
					<section>
						<p class="fragment">Although uniforms have their place, color is something we'd rather like to specify per corner of the triangle!</p>
						<p class="fragment">Let's add a color attribute to the vertices to accomplish this.</p>
						<p class="fragment">We'll first have to add the extra attributes to the vertex data.</p>
						<p class="fragment">Transparency isn't really relevant, so we'll only add the red, green and blue components:</p>
						<pre class="fragment"><code>float vertices[] = {
     0.0f,  0.5f, 1.0f, 0.0f, 0.0f, // Vertex 1: Red
     0.5f, -0.5f, 0.0f, 1.0f, 0.0f, // Vertex 2: Green
    -0.5f, -0.5f, 0.0f, 0.0f, 1.0f  // Vertex 3: Blue
};</code></pre>
					</section>
					<section>
						<p class="fragment">Then we have to change the vertex shader to take it as input and pass it to the fragment shader:</p>
						<pre class="fragment"><code>#version 330 core
in vec2 position;
in vec3 color;
out vec3 Color;
void main()
{
    Color = color;
    gl_Position = vec4(position, 0.0, 1.0);
}</code></pre>
					</section>
					<section>
						<p class="fragment">And Color is added as input to the fragment shader:</p>
						<pre class="fragment"><code>#version 330 core
in vec3 Color;
out vec4 outColor;
void main()
{
    outColor = vec4(Color, 1.0);
}</code></pre>
					</section>
					<section>
						<img src="images/OpenGL/out_in.png" class="plain" width="90%">
						<p class="fragment">Make sure that the output of the vertex shader and the input of the fragment shader have the same name, or the shaders will not be linked properly.</p>
					</section>
					<section>
						<p class="fragment">Now, we just need to alter the attribute pointer code a bit to accommodate for the new X, Y, R, G, B attribute order.</p>
						<pre class="fragment"><code>GLint posAttrib = glGetAttribLocation(shaderProgram, "position");
glEnableVertexAttribArray(posAttrib);
glVertexAttribPointer(posAttrib, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), 0);
    
GLint colAttrib = glGetAttribLocation(shaderProgram, "color");
glEnableVertexAttribArray(colAttrib);
glVertexAttribPointer(colAttrib, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)( 2 * sizeof(float)));
</code></pre>
						<p class="fragment">The fifth parameter is set to <code>5 * sizeof(float)</code> now, because each vertex consists of <code>5</code> floating point attribute values.</p>
						<p class="fragment">The offset of <code>2 * sizeof(float)</code> for the color attribute is there because each vertex starts with <code>2</code> floating point values for the position that it has to skip over.</p>
					</section>
					<section>
						<img src="images/OpenGL/colored_triangle.png" class="plain" width="70%">
					</section>
				</section>
				<section>
					<section>
						<h1>Element Buffer Objects</h1>
					</section>
					<section>
						<p class="fragment">Right now, the vertices are specified in the order in which they are drawn.</p>
						<p class="fragment">Suppose we want to draw a rectangle instead of a triangle.</p>
						<p class="fragment">We can draw a rectangle using two triangles (OpenGL mainly works with triangles).</p>
						<p class="fragment">This will generate the following set of vertices:</p>
						<pre class="fragment"><code>float vertices[] = {
     // first triangle
     0.5f,  0.5f,  // top right
     0.5f, -0.5f,  // bottom right
    -0.5f,  0.5f,  // top left
     // second triangle
     0.5f, -0.5f,  // bottom right
    -0.5f, -0.5f,  // bottom left
    -0.5f,  0.5f   // top left
};</code></pre>
					</section>
					<section>
						<pre><code>float vertices[] = {
     // first triangle
     0.5f,  0.5f,  // top right
     0.5f, -0.5f,  // bottom right
    -0.5f,  0.5f,  // top left
     // second triangle
     0.5f, -0.5f,  // bottom right
    -0.5f, -0.5f,  // bottom left
    -0.5f,  0.5f   // top left
};</code></pre>
						<p class="fragment">As you can see, there is some overlap on the vertices specified. We specify bottom right and top left twice!</p>
						<p class="fragment">This is an overhead of 50% since the same rectangle could also be specified with only 4 vertices, instead of 6.</p>
						<p class="fragment">This will only get worse as soon as we have more complex models that have over 1000s of triangles where there will be large chunks that overlap.</p>
					</section>
					<section>
						<pre><code>float vertices[] = {
     // first triangle
     0.5f,  0.5f,  // top right
     0.5f, -0.5f,  // bottom right
    -0.5f,  0.5f,  // top left
     // second triangle
     0.5f, -0.5f,  // bottom right
    -0.5f, -0.5f,  // bottom left
    -0.5f,  0.5f   // top left
};</code></pre>
						<p class="fragment">What would be a better solution is to store only the unique vertices and then specify the order at which we want to draw these vertices in.</p>
						<p class="fragment">In that case we would only have to store 4 vertices for the rectangle, and then just specify at which order we'd like to draw them.</p>
					</section>
					<section>
						<p class="fragment">An EBO is a buffer, just like a vertex buffer object, that stores indices that OpenGL uses to decide what vertices to draw.</p>
						<p class="fragment">This so called indexed drawing is exactly the solution to our problem.</p>
						<p class="fragment">To get started we first have to specify the (unique) vertices and the indices to draw them as a rectangle:</p>
						<pre class="fragment"><code>float vertices[] = {
    0.5f,  0.5f, // top right
    0.5f, -0.5f, // bottom right
   -0.5f, -0.5f, // bottom left
   -0.5f,  0.5f  // top left
};
unsigned int indices[] = {  // note that we start from 0!
    0, 1, 3,   // first triangle
    1, 2, 3    // second triangle
};</code></pre>
					</section>
					<section>
						<p class="fragment">You can see that, when using indices, we only need 4 vertices instead of 6.</p>
						<p class="fragment">Next we need to create the element buffer object:</p>
						<pre class="fragment"><code>GLuint ebo;
glGenBuffers(1, &ebo);</code></pre>
						<p class="fragment">Similar to the VBO we bind the EBO and copy the indices into the buffer with <code>glBufferData</code>.</p>
					</section>
					<section>
						<p class="fragment">Also, just like the VBO we want to place those calls between a bind and an unbind call, although this time we specify GL_ELEMENT_ARRAY_BUFFER as the buffer type.</p>
						<pre class="fragment"><code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</code></pre>
						<p class="fragment">Note that we're now giving <code>GL_ELEMENT_ARRAY_BUFFER</code> as the buffer target.</p>
						<p class="fragment">The last thing left to do is replace the <code>glDrawArrays</code> call with <code>glDrawElements</code> to indicate we want to render the triangles from an index buffer.</p>
					</section>
					<section>
						<p class="fragment">When using glDrawElements we're going to draw using indices provided in the element buffer object currently bound:</p>
						<pre class="fragment"><code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre>
						<p class="fragment">The first argument specifies the mode we want to draw in, similar to <code>glDrawArrays</code>.</p>
						<p class="fragment">The second argument is the count or number of elements we'd like to draw.</p>
						<p class="fragment">We specified <code>6</code> indices so we want to draw <code>6</code> vertices in total.</p>
						<p class="fragment">The third argument is the type of the indices which is of type <code>GL_UNSIGNED_INT</code>.</p>
					</section>
					<section>
						<pre><code>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</code></pre>
						<p class="fragment">The last argument allows us to specify an offset in the EBO (or pass in an index array, but that is when you're not using element buffer objects), but we're just going to leave this at <code>0</code>.</p>
						<p class="fragment">The <code>glDrawElements</code> function takes its indices from the EBO currently bound to the <code>GL_ELEMENT_ARRAY_BUFFER</code> target.</p>
						<p class="fragment">This means we have to bind the corresponding EBO each time we want to render an object with indices which seems again a bit cumbersome.</p>
					</section>
					<section>
						<p class="fragment">It just so happens that a vertex array object also keeps track of element buffer object bindings.</p>
						<p class="fragment">The element buffer object currently bound while a VAO is bound, is stored as the VAO's element buffer object.</p>
						<p class="fragment">Binding to a VAO thus also automatically binds its EBO.</p>
					</section>
					<section>
						<img src="images/OpenGL/ebo.png" class="plain" width="70%">
					</section>
					<section>
						<p class="fragment"><b>Note:</b></p>
						<ul>
							<li class="fragment">A VAO stores the glBindBuffer calls when the target is <code>GL_ELEMENT_ARRAY_BUFFER</code>.</li>
							<li class="fragment">This also means it stores its unbind calls so make sure you don't unbind the element array buffer before unbinding your VAO, otherwise it doesn't have an EBO configured.</li>
						</ul>
					</section>
					<section>
						<pre><code>// ..:: Initialization code :: ..
// 1. bind Vertex Array Object
glBindVertexArray(VAO);
// 2. copy our vertices array in a vertex buffer for OpenGL to use
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
// 3. copy our index array in a element buffer for OpenGL to use
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
// 4. then set the vertex attributes pointers
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);

[...]

// ..:: Drawing code (in render loop) :: ..
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)
glBindVertexArray(0);</code></pre>
					</section>
					<section>
						<img src="images/OpenGL/rectangle.png" class="plain" width="70%">
					</section>
				</section>
				<section>
					<section>
						<h1>Wireframe Mode</h1>
					</section>
					<section>
						<p class="fragment">To draw your triangles in wireframe mode, you can configure how OpenGL draws its primitives via <code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code>.</p>
						<p class="fragment">The first argument says we want to apply it to the front and back of all triangles and the second argument tells us to draw them as lines.</p>
						<p class="fragment">Any subsequent drawing calls will render the triangles in wireframe mode until we set it back to its default using <code>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</code>.</p>
					</section>
					<section>
						<img src="images/OpenGL/wireframe.png" class="plain" width="70%">
					</section>
				</section>
						
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				width: 1280,
				height: 720,
				controls: true,
				progress: true,
				center: true,
				hash: true,
				math: {
					// mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full',
					TeX: {
						Macros: {
							R: '\\mathbb{R}',
							set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
						}
					}
				},
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },					
					{ src: 'plugin/highlight/highlight.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/math/math.js', async: true }
				]
			});
		</script>
	</body>
</html>
