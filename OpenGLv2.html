<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">

		<title>OpenGL</title>

		<meta name="description" content="Computer Graphics - OpenGL">
		<meta name="author" content="Gustavo Reis">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0">

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/obsidian.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<img src="images/OpenGL/Opengl-logo.svg" width="100%" class="plain">
						<p><center><small>Source:</small></center></p>
						<p><center><small><a href="http://learnopengl.com">Learn OpenGL</a></small></center></p>
						<p><center><small><a href="http://open.gl">Open.GL</a></small></center></p>
				</section>
				<section>
					<section>
						<h1>OpenGL</h1>
						<p class="fragment">OpenGL® is the industry’s most widely adopted 2D and 3D graphics API, powering thousands of applications across a variety of computing platforms.</p>
						<p class="fragment">It is independent of windowing systems and operating systems, and is also network-transparent.</p>
					</section>
					<section>
						<h1>OpenGL</h1>
						<p class="fragment">OpenGL enables developers to create high-performance, visually compelling graphics applications on platforms ranging from PCs to supercomputers, across fields like CAD, content creation, energy, entertainment, game development, manufacturing, medical imaging, and virtual reality.</p>
						<p class="fragment">OpenGL gives developers full access to the latest features of modern graphics hardware.</p>
					</section>
				</section>
				<section>
					<section>
						<h3>Core Profile vs Immediate Mode</h3>
						<p class="fragment">In the early days of OpenGL, development was done using the fixed function pipeline, also known as immediate mode. This was an easy method for drawing graphics but lacked flexibility.</p>
						<p class="fragment">Much of OpenGL's inner workings were hidden, limiting developers' control over how graphics were processed.</p>
					</section>
					<section>
						<h3>Core Profile vs Immediate Mode</h3>
						<p class="fragment">As developers sought more flexibility, OpenGL's specifications evolved, giving developers more control over graphics rendering.</p>
						<p class="fragment">While immediate mode was easy to learn, it was also very inefficient, leading to its eventual deprecation.</p>
					</section>
					<section>
						<p class="fragment">Since version 3.2, OpenGL began deprecating immediate mode in favor of the more efficient core profile, which requires the use of modern practices and removes outdated functionality.</p>
						<p class="fragment">When developing with the core profile, using deprecated functions results in errors and no rendering.</p>
					</section>
					<section>
						<p class="fragment">Although the modern approach is more challenging to learn, it offers significantly more flexibility and efficiency, helping developers gain a deeper understanding of graphics programming.</p>
						<p class="fragment">Our classes focus on Core Profile OpenGL (version 3.3) because mastering this approach is well worth the effort.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Creating a Window and an OpenGL Context</h2>
						<p class="fragment">Before drawing anything, you need to initialize OpenGL by creating an OpenGL context. This context is a state machine that stores all rendering-related data for your application.</p>
						<p class="fragment">When the application closes, the OpenGL context is destroyed, cleaning up all resources.</p>
					</section>
					<section>
						<p class="fragment">Creating a window and OpenGL context isn’t specified in OpenGL, so the process differs across platforms.</p>
						<p class="fragment">OpenGL is designed for portability, so developers often use libraries that abstract this process, ensuring compatibility across different platforms.</p>
					</section>
					<section>
						<p class="fragment">While various libraries exist, they generally follow a similar flow: you first define window properties like title and size, as well as OpenGL context properties such as anti-aliasing settings.</p>
					</section>
					<section>
						<p class="fragment">Your application will then start the event loop, handling tasks like processing window events (e.g., mouse clicks), updating rendering state, and drawing objects.</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Normalized Device Coordinates (NDC)</h2>
						<img src="images/OpenGL/c2_dc.png" class="plain" width="80%">
					</section>
					<section>
						<h2>Normalized Device Coordinates (NDC)</h2>
						<img src="images/OpenGL/c2_dc2.png" class="plain" width="80%">
					</section>
				</section>
				<section>
					<section>
						<h3>Setup</h3>
						<p class="fragment"><b>Windows</b>: Add <code>opengl32.lib</code> to your linker.</p>
						<p class="fragment"><b>Linux</b>: Add <code>-IGL</code> to your compiler options.</p>
						<p class="fragment"><b>OS X</b>: Add <code>-framework OpenGL</code> to your compiler options.</p>
					</section>
					<section>
						<h3>SDL 2</h3>
						<pre><code>#ifdef __APPLE__
#include &lt;SDL2/SDL.h&gt;
#elif _WIN32
#include &lt;SDL.h&gt;
#endif
int main(int argc, **char argv)
{
	SDL_Init(SDL_INIT_VIDEO);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
	SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
	SDL_Window* window = SDL_CreateWindow("OpenGL", 100, 100, 800, 600, SDL_WINDOW_OPENGL);
	SDL_GLContext context = SDL_GL_CreateContext(window);
	SDL_Event windowEvent;
	while (true)
	{
		if (SDL_PollEvent(&windowEvent))
		{
			if (windowEvent.type == SDL_QUIT) break;
		}
		SDL_GL_SwapWindow(window);
	}
	SDL_GL_DeleteContext(context);
	SDL_DestroyWindow(window);
	SDL_Quit();
	return 0;
}</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h3>OpenGL Context Creation</h3>
						<pre><code>
SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);

SDL_Window* window = SDL_CreateWindow("OpenGL", 100, 100, 800, 600, SDL_WINDOW_OPENGL);
SDL_GLContext context = SDL_GL_CreateContext(window);
</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h3>GLAD</h3>
						<p class="fragment">We’re not done yet! Because OpenGL is a specification, it’s up to the graphics driver manufacturers to implement it. However, the location of OpenGL functions may vary depending on the driver version.</p>
						<p class="fragment">This means OpenGL functions need to be queried at runtime, and stored for later use.</p>
					</section>
					<section>
						<p class="fragment">GLAD is an open-source library that handles all the tedious work of retrieving and managing these OpenGL function pointers for you.</p>
						<p class="fragment">You can configure GLAD through its web service to define and load all the relevant OpenGL functions for your specific version of OpenGL.</p>
						<pre class="fragment"><code>#include &lt;glad/glad.h&gt;</code></pre>
					</section>
				</section>
				<section>
					<section>
						<pre><code>// define the function's prototype
typedef void (*GL_GENBUFFERS) (GLsizei, GLuint*);
// find the function and assign it to a function pointer
GL_GENBUFFERS glGenBuffers = (GL_GENBUFFERS)SDL_GL_GetProcAddress("glGenBuffers");
// function can now be called as normal
unsigned int buffer;
glGenBuffers(1, &buffer);
printf("%u\n", buffer);
</code></pre>
					</section>
				</section>
					<section>
						<pre><code>#include &lt;iostream&gt;
#include &lt;glad/glad.h&gt;
#ifdef __APPLE__
#include &lt;SDL2/SDL.h&gt;
#elif _WIN32
#include &lt;SDL.h&gt;
#endif
int main(int argc, char **argv)
{
	SDL_Init(SDL_INIT_VIDEO);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);
	SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
	
	SDL_Window* window = SDL_CreateWindow("OpenGL", 100, 100, 800, 600, SDL_WINDOW_OPENGL);
	if(window == nullptr)
	{
		std::cout &lt;&lt; "Failed to create SDL Window" &lt;&lt; std::endl;
		SDL_Quit();
		return -1;
	}
	
	SDL_GLContext context = SDL_GL_CreateContext(window);
	
	if(!gladLoadGLLoader((GLADloadproc)SDL_GL_GetProcAddress))
	{
		std::cout &lt;&lt; "Failed to initialize GLAD" &lt;&lt; std::endl;
		SDL_Quit();
		return -2;
	}

	SDL_Event windowEvent;
	while (true)
	{
		if (SDL_PollEvent(&windowEvent))
		{
			if (windowEvent.type == SDL_QUIT) break;
		}

		glClearColor(0.2f, 0.3f, 0.3f, 1.0f);
		glClear(GL_COLOR_BUFFER_BIT);
		SDL_GL_SwapWindow(window);
	}

	SDL_GL_DeleteContext(context);
	SDL_DestroyWindow(window);
	SDL_Quit();
	return 0;
}
</code></pre>		
					</section>
					<section><img src="images/OpenGL/screenshot.png" class="plain" width="70%">			
</section>
				</section>
				<section>
					<section>
						<h1>The Graphics Pipeline</h1>					
					</section> 
					<section>
						 <img src="images/OpenGL/c2_pipeline.png" class="plain" alt="Graphics Pipeline Overview"> <center><small>Image taken from: <a href="https://open.gl/drawing">https://open.gl/drawing</a></small></center> 
					</section> 
					<section>
						 <h2>Vertex Shader</h2> 
						 <p class="fragment">The vertex shader is the first programmable stage in the graphics pipeline. It processes individual vertices, applying transformations to convert 3D world coordinates into 2D screen coordinates.</p> 
						 <p class="fragment">This is where perspective transformations take place, projecting the 3D positions of vertices onto the 2D space of the screen.</p> 
						 <p class="fragment">Besides transforming the vertices, the vertex shader passes attributes such as color, texture coordinates, and normals down the pipeline.</p> 
					</section> 
					<section>
						 
						<p class="fragment">Once the vertices are processed, the graphics card groups them into primitives — the basic building blocks of rendering. These primitives can be triangles, lines, or points.</p> 
						 <p class="fragment">There are additional drawing modes, such as triangle strips or line strips, which reduce the number of vertices needed by connecting primitives continuously, like forming a connected line or mesh.</p> 
					</section> 
					<section>
						 <h2>Geometry Shader</h2> 
						 <p class="fragment">The geometry shader, an optional stage, was introduced more recently. Unlike the vertex shader, the geometry shader can output more vertices than it receives as input.</p> 
						 <p class="fragment">It operates on entire primitives, such as triangles or lines, and can modify, discard, or generate new primitives.</p> 
					</section> 
					<section>						 
						<p class="fragment">This stage can be especially useful when you want to minimize data transfers between the CPU and GPU. For example, in voxel games, you can pass only the positions of vertices, and the geometry shader can generate cubes or other shapes at runtime.</p> 
					</section> 
					<section>
						 <h2>Fragment Shader</h2> 
						 <p class="fragment">After the vertices and primitives are processed, the fragment shader handles the per-pixel operations.</p> 
						 <p class="fragment">The rasterizer converts the visible parts of primitives into pixel-sized fragments. The interpolated attributes from the vertex shader (or geometry shader) are passed to the fragment shader for each fragment.</p> 
						 <p class="fragment">For instance, in a triangle, even though you only specified color at three vertices, the colors across the triangle’s surface are smoothly interpolated.</p> 
						</section> 
					<section>						 
						<p class="fragment">The fragment shader calculates the final color of each fragment by using inputs such as texture coordinates, lighting calculations, and more. It’s also responsible for performing advanced effects like lighting, shadowing, and texture mapping.</p> 
					</section> 
					<section>						 
						<p class="fragment">Additionally, the fragment shader can discard fragments, making certain parts of the shape transparent or see-through. This is especially useful when rendering objects like windows or glass.</p> 
						 <p class="fragment">The final output of the fragment shader is passed through depth and stencil testing stages, where the GPU determines which fragments should be visible based on depth or stencil rules.</p> 
						</section> 
					<section>						 
						<p class="fragment">The main takeaway from depth and stencil testing is that they allow the GPU to decide which fragments are visible based on their relative position. For example, a fragment of a triangle closer to the camera will obscure fragments from triangles farther away.</p> 
					</section> </section>
				
					<section>
						<section>
							<h1>Hello Triangle</h1>
						</section>
						
						<section>
							<h2>Vertex Input</h2>
							<p class="fragment">To start drawing something, we first need to provide OpenGL with input vertex data.</p>
							<p class="fragment">OpenGL is a 3D graphics library, meaning all coordinates we specify are in 3D (x, y, and z coordinates).</p>
							<p class="fragment">However, OpenGL only processes 3D coordinates that are within a specific range:</p>
							<ul class="fragment">
								<li>Coordinates must be between -1.0 and 1.0 on all three axes (x, y, and z) to be visible on the screen.</li>
							</ul>
						</section>
						
						<section>
							<p class="fragment">Coordinates within this <strong>normalized device coordinates (NDC)</strong> range are rendered on the screen, while those outside are discarded.</p>
							<p class="fragment">To render a triangle, we need to define three vertices with 3D positions:</p>
							<pre class="fragment"><code>float vertices[] = {
  0.0f,  0.5f,  // Vertex 1 (X, Y)
  0.5f, -0.5f,  // Vertex 2 (X, Y)
 -0.5f, -0.5f   // Vertex 3 (X, Y)
};</code></pre>
						</section>
						
						<section>
							<h2>Normalized Device Coordinates (NDC)</h2>
							<p class="fragment">Once processed by the vertex shader, vertex coordinates are transformed into normalized device coordinates, where the x, y, and z values range from -1.0 to 1.0.</p>
							<p class="fragment">Any coordinates outside this range are clipped and not visible on the screen.</p>
						</section>
						
						<section>
							<p class="fragment">The following image illustrates the triangle in normalized device coordinates:</p>
							<p class="fragment"><img class="plain" src="images/OpenGL/ndc.png" width="100%" alt="Triangle in NDC"></p>
						</section>
						
						<section>
							<p class="fragment">With the vertex data defined, we send it as input to the first process of the graphics pipeline: the vertex shader.</p>
							<p class="fragment">This involves creating memory on the GPU to store the vertex data, configuring OpenGL to interpret the memory, and specifying how the data is sent to the graphics card.</p>
						</section>
						
						<section>
							<p class="fragment">We use <strong>Vertex Buffer Objects (VBOs)</strong> to store a large number of vertices in the GPU’s memory. The advantage is that we can send large batches of data all at once, avoiding the overhead of sending one vertex at a time.</p>
							<p class="fragment">The vertex shader processes vertices directly from the GPU memory, making this process extremely fast.</p>
						</section>
						
						<section>
							<p class="fragment">VBOs are OpenGL objects, identified by unique IDs. We generate a buffer ID using the <code>glGenBuffers</code> function:</p>
							<pre class="fragment"><code>GLuint vbo;
glGenBuffers(1, &vbo); // Generate 1 buffer</code></pre>
						</section>
						
						<section>
							<p class="fragment">After generating the buffer, we bind it to the <code>GL_ARRAY_BUFFER</code> target:</p>
							<pre class="fragment"><code>glBindBuffer(GL_ARRAY_BUFFER, vbo);</code></pre>
							<p class="fragment">Once bound, any operations on <code>GL_ARRAY_BUFFER</code> will apply to this buffer.</p>
						</section>
						
						<section>
							<p class="fragment">We can now copy the vertex data into the buffer's memory using the <code>glBufferData</code> function:</p>
							<pre class="fragment"><code>glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</code></pre>
						</section>
						
						<section>
							<p class="fragment"><code>glBufferData</code> takes the following arguments:</p>
							<ul class="fragment">
								<li>The buffer target (in this case, <code>GL_ARRAY_BUFFER</code>).</li>
								<li>The size of the data being passed (using <code>sizeof(vertices)</code>).</li>
								<li>The actual vertex data to store in the buffer.</li>
								<li>A usage hint to tell the GPU how we intend to use this data (e.g., <code>GL_STATIC_DRAW</code>, <code>GL_DYNAMIC_DRAW</code>, or <code>GL_STREAM_DRAW</code>).</li>
							</ul>
							<p class="fragment">Since the vertex data will rarely change, we use <code>GL_STATIC_DRAW</code> for optimal performance.</p>
						</section>
						
						<section>
							<h2>Vertex Shader</h2>
							<p class="fragment">The <strong>vertex shader</strong> processes each vertex and its attributes from the vertex buffer. Its role is to output the final vertex position in device coordinates and pass relevant data to the fragment shader.</p>
							<pre class="fragment"><code>#version 330 core
layout (location = 0) in vec2 position;
void main()
{
	gl_Position = vec4(position, 0.0, 1.0);
}</code></pre>
							<p class="fragment">This GLSL (OpenGL Shading Language) shader takes a 2D position as input and sets the <code>gl_Position</code> to output the position in 3D space.</p>
						</section>
						
						<section>
							<h2>Fragment Shader</h2>
							<p class="fragment">The <strong>fragment shader</strong> determines the color of each pixel (or fragment) that makes up the shapes drawn on the screen. For now, the fragment shader will output a fixed color:</p>
							<pre class="fragment"><code>#version 330 core
out vec4 outColor;
void main()
{
	outColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);  // Orange color
}</code></pre>
						</section>
						<section>
							<h2>Compiling Shaders</h2>
							<p class="fragment">To use shaders in OpenGL, we first need to compile them at runtime. Let's start with the vertex shader.</p>
							<p class="fragment">We write the vertex shader source code as a string, and OpenGL dynamically compiles it:</p>
							<pre class="fragment"><code>const char* vertexShaderSource = R"glsl(
#version 330 core
layout (location = 0) in vec2 position;
void main()
{
	gl_Position = vec4(position, 0.0, 1.0);
}
)glsl";</code></pre>
						</section>
						
						<section>
							<p class="fragment">To compile the shader, we first create a shader object, attach the source code to it, and compile it:</p>
							<pre class="fragment"><code>GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER); // Create a vertex shader
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL); // Attach the shader source code
glCompileShader(vertexShader); // Compile the shader</code></pre>
						</section>
						
						<section>
							<p class="fragment">It's important to check whether the shader compiled successfully. If not, we can retrieve the error message using the following code:</p>
							<pre class="fragment"><code>GLint success;
char infoLog[512];
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &success);
if (!success)
{
	glGetShaderInfoLog(vertexShader, 512, NULL, infoLog);
	std::cout << "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n" << infoLog << std::endl;
}</code></pre>
						</section>
						
						<section>
							<p class="fragment">The fragment shader is compiled in a similar manner:</p>
							<pre class="fragment"><code>const char* fragmentShaderSource = R"glsl(
#version 330 core
out vec4 outColor;
void main()
{
	outColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);  // Orange color
}
)glsl";

GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); // Create a fragment shader
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL); // Attach the shader source code
glCompileShader(fragmentShader); // Compile the shader</code></pre>
						</section>
						
						<section>
							<p class="fragment">Similarly, you should check for errors after compiling the fragment shader:</p>
							<pre class="fragment"><code>glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
if (!success)
{
	glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
	std::cout << "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" << infoLog << std::endl;
}</code></pre>
						</section>
						
						<section>
							<h2>Linking Shaders into a Shader Program</h2>
							<p class="fragment">After compiling the shaders, we need to link them into a shader program. First, create a program object:</p>
							<pre class="fragment"><code>GLuint shaderProgram = glCreateProgram();</code></pre>
						</section>
						
						<section>
							<p class="fragment">Next, attach the compiled vertex and fragment shaders to the program and link them:</p>
							<pre class="fragment"><code>glAttachShader(shaderProgram, vertexShader);  // Attach the vertex shader
glAttachShader(shaderProgram, fragmentShader);  // Attach the fragment shader
glLinkProgram(shaderProgram);  // Link the shader program</code></pre>
						</section>
						
						<section>
							<p class="fragment">Again, it's a good idea to check if linking was successful:</p>
							<pre class="fragment"><code>glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
if (!success)
{
	glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
	std::cout << "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" << infoLog << std::endl;
}</code></pre>
						</section>
						
						<section>
							<p class="fragment">Once the shaders are linked into the program, we no longer need the individual shader objects, so they can be deleted:</p>
							<pre class="fragment"><code>glDeleteShader(vertexShader); // Delete the vertex shader
glDeleteShader(fragmentShader); // Delete the fragment shader</code></pre>
						</section>
						
						<section>
							<p class="fragment">Now, the <code>shaderProgram</code> contains the linked shaders, and we can use it in our render loop by calling:</p>
							<pre class="fragment"><code>glUseProgram(shaderProgram);</code></pre>
						</section>
						<section>
							<h3>Linking Vertex Attributes</h3>
							<p class="fragment">After creating the shaders, OpenGL needs to know how to interpret the vertex data in memory and how to link this data to the vertex shader's attributes.</p>
							<p class="fragment">This step involves linking the vertex data to the attributes declared in the vertex shader. In this case, we need to link the position attribute.</p>
						</section>
						
						<section>
							<p class="fragment">First, we define the vertex data (positions of the triangle) in an array:</p>
							<pre class="fragment"><code>float vertices[] = {
	0.0f,  0.5f,  // Vertex 1 (X, Y)
	0.5f, -0.5f,  // Vertex 2 (X, Y)
	-0.5f, -0.5f   // Vertex 3 (X, Y)
};</code></pre>
							<p class="fragment"><img src="images/OpenGL/stride.png" class="plain"></p>
						</section>
						
						<section>
							<img src="images/OpenGL/stride.png" class="plain" width="60%">
							<p class="fragment">The position attribute is stored as two floating point values per vertex, representing the X and Y coordinates. We will link this data to the <code>position</code> attribute in the vertex shader.</p>
							<p class="fragment">The position data is stored as 32-bit (4 byte) floating point values.</p>
							<p class="fragment">Each position is composed of 2 of those values.</p>
							<p class="fragment">There is no space (or other values) between each set of 2 values. The values are tightly packed in the array.</p>
							<p class="fragment">The first value in the data is at the beginning of the buffer.</p>
						</section>
						
						<section>
							<p class="fragment">To link the vertex data to the vertex attribute, we use the <code>glVertexAttribPointer</code> function:</p>
							<pre class="fragment"><code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);</code></pre>
						
						</section>
						
						<section>
							<pre class="fragment"><code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);</code></pre>
							<p class="fragment">Let’s break down the parameters of <code>glVertexAttribPointer</code>:</p>
							<ul class="fragment">
								<li><b>0</b>: The index of the vertex attribute. We specified the position attribute to have location 0 in the vertex shader using <code>layout (location = 0)</code>.</li>
								<li><b>2</b>: The number of components per vertex attribute. Each position consists of two components: X and Y.</li>
								<li><b>GL_FLOAT</b>: The data type of each component, which is <code>float</code>.</li>
								<li><b>GL_FALSE</b>: Whether the data should be normalized. We set this to false because the data is already in the correct format.</li>
								<li><b>2 * sizeof(float)</b>: The stride, which specifies the byte offset between consecutive vertex attributes. Since each vertex consists of two floats (X and Y), the stride is <code>2 * sizeof(float)</code>.</li>
								<li><b>(void*)0</b>: The offset of the first component of the attribute in the array. Here, it is <code>0</code> since the position attribute is the first data in the array.</li>
							</ul>
						</section>
						
						<section>
							<p class="fragment">After specifying the layout of the vertex data, we enable the vertex attribute at location 0 using:</p>
							<pre class="fragment"><code>glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);</code></pre>
						</section>
						
						<section>
							<p class="fragment">Once linked, the vertex attribute configuration is stored in a Vertex Array Object (VAO). You only need to specify this configuration once, and OpenGL will remember it.</p>
						</section>
						
						<section>
							<p class="fragment">This setup ensures that when we render our objects, the vertex data is correctly linked to the position attribute in the vertex shader.</p>
						</section>
						<section>
							<h3>Vertex Array Object (VAO)</h3>
							<p class="fragment">In OpenGL, a Vertex Array Object (VAO) stores the configuration of the vertex attributes and the buffers associated with them. This allows you to set up vertex attributes once and reuse them during rendering.</p>
						</section>
						
						<section>
							<p class="fragment">A VAO can be bound just like any buffer object, and any vertex attribute calls made after binding the VAO will be stored in it.</p>
						</section>
						
						<section>
							<p class="fragment">This is how we generate and bind a VAO:</p>
							<pre class="fragment"><code>GLuint vao;
glGenVertexArrays(1, &vao);
glBindVertexArray(vao);</code></pre>
						</section>
						
						<section>
							<p class="fragment">The <code>glGenVertexArrays</code> function generates a VAO, and <code>glBindVertexArray</code> makes it the current active VAO. All subsequent vertex attribute calls will be stored in this VAO.</p>
						</section>
						
						<section>
							<p class="fragment">Next, we bind the VBO and configure the vertex attributes as shown in the previous sections:</p>
							<pre class="fragment"><code>// 1. Bind the VAO
glBindVertexArray(vao);

// 2. Copy the vertex data into a VBO
glBindBuffer(GL_ARRAY_BUFFER, vbo);
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

// 3. Set up the vertex attribute pointers
glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 2 * sizeof(float), (void*)0);
glEnableVertexAttribArray(0);</code></pre>
						</section>
						
						<section>
							<p class="fragment">At this point, we have stored the vertex data configuration (using VBO) and vertex attribute pointers (using <code>glVertexAttribPointer</code>) inside the VAO. Now, we can unbind the VAO to avoid accidentally modifying it:</p>
							<pre class="fragment"><code>glBindVertexArray(0);</code></pre>
						</section>
						
						<section>
							<p class="fragment">When we want to render an object, we simply bind the VAO, and OpenGL will automatically use the stored configuration:</p>
							<pre class="fragment"><code>// Bind the VAO before drawing
glBindVertexArray(vao);
glDrawArrays(GL_TRIANGLES, 0, 3);
glBindVertexArray(0);</code></pre>
						</section>
						
						<section>
							<p class="fragment">By binding the VAO, OpenGL automatically uses the associated vertex attributes and buffers. This allows you to efficiently switch between different objects by simply binding different VAOs.</p>
						</section>
						
						<section>
							<p class="fragment">The VAO stores the following information:</p>
							<ul class="fragment">
								<li>Vertex attribute configurations such as <code>glVertexAttribPointer</code> calls</li>
								<li>Enabled/disabled state of vertex attributes via <code>glEnableVertexAttribArray</code></li>
								<li>Which VBOs are associated with which vertex attributes</li>
							</ul>
						</section>
						
						<section>
							<p class="fragment"><b>Important Note:</b></p>
							<ul class="fragment">
								<li>In OpenGL's core profile, using a VAO is mandatory for rendering objects. Failing to bind a VAO will result in nothing being drawn.</li>
							</ul>
						</section>
						
						<section>
							<img src="images/OpenGL/vao.png" class="plain" width="70%">
						</section>
						
						<section>
							<p class="fragment">In summary, the VAO encapsulates the state of all the vertex attribute configurations and buffer associations, allowing for efficient rendering of different objects by switching VAOs.</p>
						</section>
						
						<section>
							<h2>Drawing the Triangle</h2>
							<p class="fragment">After configuring vertex and fragment shaders, we can now draw our triangle using the <code>glDrawArrays</code> function:</p>
							<pre class="fragment"><code>glUseProgram(shaderProgram);
glBindVertexArray(vao);
glDrawArrays(GL_TRIANGLES, 0, 3);</code></pre>
							<p class="fragment">The function draws 3 vertices starting at index 0 as a triangle.</p>
						</section>
						
						<section>
							<img src="images/OpenGL/orange_triangle.png" class="plain" width="70%" alt="Orange Triangle">
						</section>
						
						<section>
							<h2>Uniforms</h2>
							<p class="fragment">We can also change the color of the triangle after compiling the shader by using <strong>uniforms</strong>, which are global variables available in shaders. Here's how we modify the triangle's color dynamically:</p>
							<pre class="fragment"><code>#version 330 core
uniform vec3 triangleColor;
out vec4 outColor;
void main()
{
	outColor = vec4(triangleColor, 1.0);
}</code></pre>
						</section>
						
						<section>
							<p class="fragment">You can update the uniform value in your C++ code by retrieving the uniform location and setting its value with <code>glUniform</code> functions:</p>
							<pre class="fragment"><code>GLint uniColor = glGetUniformLocation(shaderProgram, "triangleColor");
glUniform3f(uniColor, 1.0f, 0.0f, 0.0f);  // Red color</code></pre>
							<p class="fragment">This will change the triangle's color to red.</p>
						</section>
						
						<section>
							<img src="images/OpenGL/red_triangle.png" width="65%" class="plain" alt="Red Triangle">
						</section>
					</section>
						
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				width: 1280,
				height: 720,
				controls: true,
				progress: true,
				center: true,
				hash: true,
				math: {
					// mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full',
					TeX: {
						Macros: {
							R: '\\mathbb{R}',
							set: [ '\\left\\{#1 \\; ; \\; #2\\right\\}', 2 ]
						}
					}
				},
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },					
					{ src: 'plugin/highlight/highlight.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/math/math.js', async: true }
				]
			});
		</script>
	</body>
</html>
